<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React on yyh-gl's Tech Blog</title><link>https://tech.yyh-gl.dev/categories/react/</link><description>Recent content in React on yyh-gl's Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Mon, 02 Dec 2019 09:00:00 +0900</lastBuildDate><atom:link href="https://tech.yyh-gl.dev/categories/react/index.xml" rel="self" type="application/rss+xml"/><item><title>【React+TypeScript】TypeScript入門</title><link>https://tech.yyh-gl.dev/blog/react_typescript_sample/</link><pubDate>Mon, 02 Dec 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/react_typescript_sample/</guid><description>&lt;h1 id="typescript-advent-calendar-2019">TypeScript Advent Calendar 2019&lt;/h1>
&lt;img src="https://tech.yyh-gl.dev/img/2019/12/react_typescript_sample/qiita_advent_calendar_2019.png" width="700">
&lt;p>本記事は &lt;a href="https://qiita.com/advent-calendar/2019/typescript" target="_blank" rel="noopener noreferrer">TypeScript Advent Calendar 2019&lt;/a>
の 2 日目の記事です。&lt;/p>
&lt;p>内容としては、TypeScript 初級者のための TypeScript 入門です。&lt;/p>
&lt;p>基礎的な内容から入り、&lt;br>
最終的には、企業や個人の技術ブログを参考に、&lt;br>
React の実プロジェクトにおいて、&lt;br>
どのように TypeScript が使われているのか紹介できればと思います。&lt;br>
（APIリクエスト周りのTypeScript活用事例を紹介）&lt;/p>
&lt;p>今日の記事を読んで TypeScript に入門し、&lt;br>
今後の TypeScript Advent Calendar をお楽しみいただけると幸いです！&lt;/p>
&lt;h1 id="基礎編">基礎編&lt;/h1>
&lt;h2 id="typescript-とは">TypeScript とは&lt;/h2>
&lt;img src="https://tech.yyh-gl.dev/img/2019/12/react_typescript_sample/ts.png" width="200">
&lt;p>&lt;a href="https://www.typescriptlang.org/index.html" target="_blank" rel="noopener noreferrer">TypeScript&lt;/a>
は Microsoft 社によって開発され、
現在は &lt;a href="https://github.com/microsoft/TypeScript" target="_blank" rel="noopener noreferrer">OSS&lt;/a>
として開発が進められています。&lt;/p>
&lt;p>「TypeScript とは何か」を簡単に説明すると、&lt;br>
&lt;u>JavaScript に対して、省略も可能な静的型付けとクラスベースオブジェクト指向を加えたスーパーセット&lt;/u> です。&lt;/p>
&lt;p>&lt;a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">公式サイト&lt;/a>
はこちらで、&lt;br>
2019年12月2日現在、最新版は 3.7.2 となっています。&lt;/p>
&lt;p>では、実際にコードを交えながら基礎的な部分を説明していきます。&lt;br>
ただし、実践編で使用する内容に絞って説明していきますので、&lt;br>
その点はご了承ください🙇‍&lt;br>
（足りない情報は&lt;a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener noreferrer">公式ドキュメント&lt;/a>
を参考にしてください）&lt;/p>
&lt;h2 id="型">型&lt;/h2>
&lt;p>では、早速、TypeScript の型に触れていきましょう。&lt;br>
TypeScript で使用できる基本的な型として以下のものがあります。&lt;/p>
&lt;ul>
&lt;li>Boolean&lt;/li>
&lt;li>Number&lt;/li>
&lt;li>String&lt;/li>
&lt;li>Array&lt;/li>
&lt;li>Tuple&lt;/li>
&lt;li>Enum&lt;/li>
&lt;li>Any&lt;/li>
&lt;li>Void&lt;/li>
&lt;li>Null and Undefined&lt;/li>
&lt;li>Never&lt;/li>
&lt;li>Object&lt;/li>
&lt;/ul>
&lt;p>だいたいの型は他言語でも用意されているので、&lt;br>
説明がなくても理解できると思います。&lt;/p></description></item><item><title>React.memo について調べたのでメモを残しておく</title><link>https://tech.yyh-gl.dev/blog/react_memo/</link><pubDate>Wed, 18 Sep 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/react_memo/</guid><description>&lt;h1 id="reactmemo-とは">React.memo とは&lt;/h1>
&lt;p>&lt;a href="https://ja.reactjs.org/docs/react-api.html#reactmemo" target="_blank" rel="noopener noreferrer">公式ドキュメント&lt;/a>
を見ると、&lt;/p>
&lt;blockquote>
&lt;p>これは React.PureComponent に似ていますが、クラスではなく関数コンポーネント用です。&lt;/p>&lt;/blockquote>
&lt;p>とあります。&lt;/p>
&lt;p>つまり、 React.PureComponent を関数コンポーネントで実現するための手段らしいです。&lt;/p>
&lt;h1 id="reactpurecomponent-とは">React.PureComponent とは&lt;/h1>
&lt;p>&lt;a href="https://ja.reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener noreferrer">公式ドキュメント&lt;/a>
を見ると、&lt;/p>
&lt;blockquote>
&lt;p>React.PureComponent は React.Component と似ています。
両者の違いは React.Component が shouldComponentUpdate() を実装していないことに対し、
React.PureComponent は props と state を浅く (shallow) 比較することでそれを実装していることです。&lt;/p>&lt;/blockquote>
&lt;p>とあります。&lt;/p>
&lt;p>&lt;u>shouldComponentUpdate() によって、どういった変更があれば再描画するかを定義する&lt;/u>ようです。&lt;/p>
&lt;br>
&lt;p>追加でこの&lt;a href="https://the2g.com/2814" target="_blank" rel="noopener noreferrer">参考記事&lt;/a>
を読んでみると、&lt;/p>
&lt;blockquote>
&lt;p>PureComonentはprops及びstateの変更を検出した場合のみレンダリングを行います。
Messageコンポーネントではmessage propsの変更を察知し、必要分の更新を行うようになります。&lt;/p>&lt;/blockquote>
&lt;p>とあります。&lt;/p>
&lt;p>自分で再描画条件を定義できるので、無駄な再描画を省くことができ、パフォーマンス向上を期待できるんですね。&lt;/p>
&lt;p>→ React.PureComponent を用いることでパフォーマンスを向上させることができるようです。&lt;br>
（参考記事内にもあるとおり銀の弾丸ではないようですが…）&lt;/p>
&lt;h1 id="浅い比較-とは">浅い比較 とは&lt;/h1>
&lt;blockquote>
&lt;p>shouldComponentUpdate() は浅い比較によって変更検知を行う。&lt;/p>&lt;/blockquote>
&lt;p>とありましたが、浅い比較とはなんでしょうか。&lt;br>
（shouldComponentUpdate() のデフォルトが浅い比較というだけで、オリジナルの比較方法を実装可能なようです）&lt;/p>
&lt;p>さきほどの&lt;a href="https://the2g.com/2814" target="_blank" rel="noopener noreferrer">参考記事&lt;/a>
にて説明されていました。&lt;/p>
&lt;blockquote>
&lt;p>浅い比較というのは、簡潔に述べるとオブジェクトの参照先が同じであれば等しいと見なすことです。&lt;/p>&lt;/blockquote>
&lt;p>参照先しか見ていないので、中身は見ていないということですね。&lt;br>
（このような実装なのは、React の思想として、props や state といったデータは immutable であるべきだとしているからだと思います）&lt;/p></description></item></channel></rss>