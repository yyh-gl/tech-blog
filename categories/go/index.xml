<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on yyh-gl's Tech Blog</title><link>https://tech.yyh-gl.dev/categories/go/</link><description>Recent content in Go on yyh-gl's Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sun, 09 Apr 2023 00:25:48 +0900</lastBuildDate><atom:link href="https://tech.yyh-gl.dev/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>gomockのgenerics対応状況</title><link>https://tech.yyh-gl.dev/blog/gomock-generics/</link><pubDate>Sun, 09 Apr 2023 00:25:48 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/gomock-generics/</guid><description>gomock gomock はGo用のモック生成ツールです。
今回はこのgomockのgenerics対応状況について共有します。
gomockのgenerics対応状況 残念ながらgomockはまだgenericsに対応していません。
ただし、generics対応がリリースされていないだけで、 すでにmainブランチには generics対応のPR がマージされています （Issueはこちら ）。 したがって、go install github.com/golang/mock/mockgen@mainとすればgenerics対応したgomockを利用可能です。
いつリリース？ v1.7.0としてリリース予定らしく、すでにタグは作成されています。 https://github.com/golang/mock/releases/tag/v1.7.0-rc.1 ただ、タグが作成されてからもうすぐ1年が経とうとしています…
無事リリースされることを祈りましょう。
（タグがあるのでgo install github.com/golang/mock/mockgen@v1.7.0-rc.1でもOKですね）
まとめ generics対応したgomockを使いたい場合は、 go install github.com/golang/mock/mockgen@mainか go install github.com/golang/mock/mockgen@v1.7.0-rc.1を実行しましょう。</description></item><item><title>徒然なるままに go build と build tag を見ていく</title><link>https://tech.yyh-gl.dev/blog/go-build/</link><pubDate>Sun, 19 Dec 2021 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/go-build/</guid><description>本記事は『Go #1 Advent Calendar 2021 19日目 』の記事です。
はじめに Goには標準で便利なコマンドがたくさんあります。
有名どころで言えば、
generate fmt vet などがあります。
中でも、Goのコードをコンパイルするためのbuildコマンドは、 みなさんも日頃の開発で使用しているのではないでしょうか。
buildは特に難しいことをしなければ、とてもシンプルに使えるコマンドです。
よって、直感的に「こうすればコンパイルできるんでしょー」くらいの感覚で、 ドキュメントを注視しなくても使い始められるでしょう。
しかし、buildは深く見ていくと意外と奥が深いコマンドです。
今回はそんなbuildについて深ぼっていこうと思います。
buildコマンドとは まずはbuildとはどういったコマンドなのか見ていきましょう。
helpを使って調べてみます。
$ go help build Build compiles the packages named by the import paths, along with their dependencies, but it does not install the results. &amp;lt;省略&amp;gt; When compiling packages, build ignores files that end in '_test.go'. &amp;lt;省略&amp;gt; When compiling multiple packages or a single non-main package, build compiles the packages but discards the resulting object, serving only as a check that the packages can be built.</description></item><item><title>【GitHub Actions】GitHubのプロフィールを自動更新する仕組みを作った</title><link>https://tech.yyh-gl.dev/blog/profile-readme-updater/</link><pubDate>Fri, 19 Feb 2021 18:53:19 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/profile-readme-updater/</guid><description>おもしろいツイートを見つけた GitHub ActionsでQiita/Zennの投稿をGitHubプロフィールに自動反映できるようにした pic.twitter.com/o47E7YHSsx
&amp;mdash; mikkame (@mikkameee) February 14, 2021 とても便利そうだったので僕もやってみました。
作った ↑こんな感じで Recent posts - Blog 📝 に直近5個のブログ記事を表示するようにして、
なおかつ自動で更新されるようにしました。
コードはこちら に置いてあります。
やっていることはとてもシンプルで、
Goで書いたプロフィール（README）更新スクリプトをGitHub Actionsで実行しているだけです。
興味あったらコードを覗いてみてください。</description></item><item><title>The Go Programming Language Specificationで知った「こんなことできるだ」を紹介</title><link>https://tech.yyh-gl.dev/blog/uncredible-codes-from-go-spec/</link><pubDate>Tue, 08 Dec 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/uncredible-codes-from-go-spec/</guid><description>本記事は『Go 5 Advent Calendar 2020 8日目 』の記事です。
Go Language Specification輪読会 現在、Go Language Specification輪読会 という、 Goの言語仕様 を読んでいく会に参加しています。
今回は、そんな輪読会で「こんなことできるんだ」と驚いたコードを紹介します。
（振り返ると結構たくさんあったので、今回はその中から5個選んで紹介します）
ちなみに、だいたいのコードは現場で使うと怒られそうです😇 （いや、まず間違いなく怒られる）
1. Comments package main import ( &amp;quot;fmt&amp;quot; ) func main() { var/*comment*/a = 1 fmt.Println(a) } https://play.golang.org/p/9Dun0LiT5N5 まずはこちら。
変な位置にコメントが挿入されています。
コメント部分を消すとvara = 1となるのでエラーになりそうです。
しかし、実行してみると、すんなりと変数aを表示してくれます。
解説 Spec を参照すると以下の一文があります。
A general comment containing no newlines acts like a space.
改行を含まないgeneral commentはスペースのように作用する。
（general commentとは/**/で囲われたコメントのことを指します）
よって、先程のコードは以下と同じということです。
package main import ( &amp;quot;fmt&amp;quot; ) func main() { var a = 1 fmt.</description></item><item><title>【Go】Switch文のfallthroughに関するまとめ</title><link>https://tech.yyh-gl.dev/blog/go-switch-fallthrough/</link><pubDate>Sat, 03 Oct 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/go-switch-fallthrough/</guid><description>fallthrough とは GoではSwitch文でfallthroughというキーワード が使用可能です。
機能としては、処理を次の節（caseやdefault）に進めます。（参考 ）
言葉で説明するよりも、サンプルコードを見てもらった方がイメージしやすいと思います。
package main import &amp;quot;fmt&amp;quot; func main() { num := 1 switch num { case 1: fmt.Print(&amp;quot;I &amp;quot;) fallthrough case 2: fmt.Print(&amp;quot;am &amp;quot;) fallthrough case 3: fmt.Println(&amp;quot;yyh-gl.&amp;quot;) // fallthrough // 次の節がなければコンパイルエラー } } // 実行結果： // I am yyh-gl. Playground defaultにも飛べるという例 fallthroughは、Go言語のORMライブラリとして有名な『GORM』でも使用されています。(使用箇所 )</description></item><item><title>Goの参照渡しについて調べてみた</title><link>https://tech.yyh-gl.dev/blog/go-always-passing-by-value/</link><pubDate>Sun, 14 Jun 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/go-always-passing-by-value/</guid><description>Goにおける参照渡し＝ポインタの値渡し Goでは関数にパラメータを渡すとき、全て値渡しで実現されています。
（C派生の言語はすべてそうらしいです）
じゃあ、参照渡しって何？ってなりますよね。
参照渡し＝ポインタの値渡しです。
つまり、ポインタそのものを渡しているわけではなく、ポインタのコピーを渡しています。
値渡しと参照渡しの差は、内部の値をコピーするかどうかです。
こちらについては後ほど例を交えて説明します。
今回の内容はGo公式ドキュメントの『Pointers and Allocation』 の章に 詳細な記載があります。
本記事では、『Pointers and Allocation』 から要点を抜粋して紹介します。
値渡しと参照渡しの違いは内部値のコピー有無 まずは、先述した
値渡しと参照渡しの差は、内部の値をコピーするかどうかです。
について詳しく見ていきます。
公式ドキュメント『When are function parameters passed by value?』 の節に以下の記述があります。
For instance, passing an int value to a function makes a copy of the int, and passing a pointer value makes a copy of the pointer, but not the data it points to.
たとえば、int値を関数に渡すとintのコピーが作成され、ポインター値を渡すとポインターのコピーが作成されますが、ポインターが指すデータは作成されません。
つまり、
値渡し：値のコピーが作成される 参照渡し：ポインタのコピーは作成されるが、ポインタが指すデータ（値）のコピーは作成しない といった差があります。
図にすると以下のとおりです。
同じ色の箱はアドレスが同じだと考えてください。
（図が下手なところはほっといてあげてください🙇‍♂️）</description></item><item><title>【Go+DDD】エンティティと値オブジェクトの実装方法（自己流）</title><link>https://tech.yyh-gl.dev/blog/go-ddd-entity-vo/</link><pubDate>Fri, 08 May 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/go-ddd-entity-vo/</guid><description>GoでDDD 今担当しているプロジェクトでは、GoでAPIを作っています。
このプロジェクトでは、DDDの考え方や設計パターンも取り入れています。
今回はDDDの設計パターンの中でもEntityとValue Object（VO）について、
僕がGoでどうやって実装しているのか紹介していきます。
実装例 兎にも角にも、まずはコードを示します。
// animal/dog/dog.go package dog type Dog struct { name Name } func New(name string) (*Dog, error) { n, err := newName(name) if err != nil { return nil, err } return &amp;amp;Dog{ name: *n, }, nil } // animal/dog/name.go package dog import ( &amp;quot;errors&amp;quot; &amp;quot;unicode/utf8&amp;quot; ) type Name string func newName(v string) (*Name, error) { // 名前は3文字以上というビジネスロジック if utf8.RuneCountInString(v) &amp;lt; 3 { return nil, errors.</description></item><item><title>go test におけるキャッシュの消し方</title><link>https://tech.yyh-gl.dev/blog/go-test-cache-clear/</link><pubDate>Thu, 30 Apr 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/go-test-cache-clear/</guid><description>go test のキャッシュを消すのは簡単 $ go clean -testcache
以上です！
$ go test ./... ok github.com/oxequa/realize (cached) ok github.com/oxequa/realize/realize (cached) このように (cached) となっていたものが、、、
$ go clean -testcache $ go test ./... ok github.com/oxequa/realize 0.086s ok github.com/oxequa/realize/realize 0.389s このように、実行時間が表示されており、キャッシュが消えていることが分かりますね。
ちなみに、キャッシュを無視する方法はもうひとつあり、
以下のように -count=1 をつけてやればOKです。
$ go test ./... -count=1 ok github.com/oxequa/realize 0.076s ok github.com/oxequa/realize/realize 0.384s ここからは上記コマンドが一体なにをしてくれたのか、
もう少し詳細に話していきます。
go clean とは こちら にドキュメントがあります。
Clean removes object files from package source directories.
go clean は上記のとおりファイルを消してくれるわけですね。
-testcache オプションをつけると、</description></item><item><title>【Go】jsonパッケージの知っておくと便利な機能</title><link>https://tech.yyh-gl.dev/blog/go-json-tips/</link><pubDate>Sun, 26 Apr 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/go-json-tips/</guid><description>jsonパッケージ Goを触ってる人ならだれもが一度はお世話になるであろう パッケージ「json 」
今回はそんな json パッケージについて、
知っておくと便利な機能を2つ紹介します。
（比較的有名なものしかないですが🙏）
1. 独自の変換ロジックを実装できる 例えば、下記のコードのように、
ある構造体（Human）のフィールドを外部公開したくない場合、
jsonパッケージの Unmarshal()，Marshal() が使えません。
（上記関数は外部公開されたフィールドのみ変換できる）
type Human struct { // フィールドを外部公開したくない name string age int } func main() { h := Human{ name: &amp;quot;Taro&amp;quot;, age: 21, } // 構造体 → JSON j, _ := json.Marshal(h) fmt.Println(string(j)) // {} // JSON → 構造体 var uh Human _ = json.Unmarshal(j, &amp;amp;uh) fmt.Printf(&amp;quot;%+v\n&amp;quot;, uh) // {name: age:0} } playgroud 実際に実行してみると、うまく変換できていないことが分かると思います。
さて、このときどうすれば正しく変換できるかというと、</description></item><item><title>【Go】errorの同値性と表示について調べた</title><link>https://tech.yyh-gl.dev/blog/error_questions/</link><pubDate>Tue, 10 Mar 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/error_questions/</guid><description>errorについて疑問があった Goのコードを書いてて、ふと気になったことがあったので調べてみました。
errorの同値性 1つ目の疑問は、下記コードで e1 と e2 がイコールではないことです。 （同値性なんて仰々しく言ってすみません。たったこれだけの疑問です😇🙇‍♂️）
func main() { e1 := errors.New(&amp;quot;error1&amp;quot;) e2 := errors.New(&amp;quot;error1&amp;quot;) e3 := e1 fmt.Println(e1 == e2) // false fmt.Println(e1 == e3) // true } Playground 結論（errorの同値性） errors.New() が返しているのがポインタでした。
つまり、さきほどのコードの6行目はポインタの値を比較しているので、そりゃfalseになりますね。
errorの表示 2つ目の疑問は、下記コードで e1 を表示すると、
errors.New()の戻り値である構造体の値ではなく、エラー文言が表示されることです。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;errors&amp;quot; ) func main() { e1 := errors.New(&amp;quot;error1&amp;quot;) fmt.Println(e1) // error1 } Playground errors.New()が返しているのは構造体なので、
下記コードのように構造体の内容が表示されないのはなんでだ？ってなったわけです。
package main import &amp;quot;fmt&amp;quot; func Hoge() interface{} { type hoge struct { s string } return &amp;amp;hoge{s: &amp;quot;hoge&amp;quot;} } func main() { h := Hoge() fmt.</description></item><item><title>【Go】errorsパッケージの中身覗いてみた</title><link>https://tech.yyh-gl.dev/blog/errors_package/</link><pubDate>Mon, 09 Mar 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/errors_package/</guid><description>errorsパッケージに興味持った v1.13からerrorsパッケージに Unwrap() Is() As() といった関数が追加されました。
（もう1.14もリリースされているのに今さらですね😇）
今回はこれら3つの関数について、内部実装を追いかけていきます。
と、その前に、errorsパッケージの概要と関連パッケージについて軽く説明しておきます。
errorsパッケージと関連パッケージ errorsパッケージ 名前の通り、エラー関連の処理がまとまっているパッケージですね。
Goの標準パッケージです。
→ GoDoc v1.13にて、先述の Unwrap() Is() As() という関数たちが追加されました。
errorを扱うパッケージとして、もうひとつ有名なパッケージがあります。
xerrorsパッケージです。
xerrorsパッケージ xerrors とは、 Goのサブリポジトリ で開発が進められているパッケージです。
（準標準パッケージといった感じでしょうか）
xerrorsのGoDoc に下記の記述がある通り、
These functions were incorporated into the standard library&amp;rsquo;s errors package in Go 1.13: - Is - As - Unwrap
もともとは本パッケージに Unwrap() Is() As() が実装されていましたが、
v1.13にて標準パッケージに取り込まれました。
さて、軽くerror関連のパッケージについて触れたところで、
早速、Unwrap() Is() As() の内部実装を見ていきたいと思います。
なお、Goのコードはv1.14.0を参照しています。
Unwrap() ラップされたエラーから中身のエラーを取り出す関数です。
処理としては下記のようになっています。
func Unwrap(err error) error { u, ok := err.</description></item><item><title>Goのバージョン管理について</title><link>https://tech.yyh-gl.dev/blog/go-versions/</link><pubDate>Tue, 03 Mar 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/go-versions/</guid><description>Goのバージョン管理 注意1：本記事はGo自体のバージョン管理についてです。Go Modulesなどは対象外です。 注意2：基本的にMacユーザを対象にしています。（WindowsとLinuxももちろん好きです）
開発において言語のバージョン管理はつきものだと思います。
そのニーズは高く、rbenv や nodenv といったバージョン管理ツールが普及しています。
ただし、Goの場合は少し話が変わってきます。
もちろんGoでも goenv が用意されていますが、
（今のところ）Goは後方互換性が担保されているので、基本的に最新バージョンに上げ続ければOKです。
…と言いつつも、GAEを使用するといった場合に、どうしてもバージョン管理したくなることがあると思います。
そこで今回はまずGoのバージョン管理ツールの紹介をした後で、
最新バージョンをインストールする方法を紹介していきたいと思います。
Goのバージョン管理ツール ▼ goenv ◯◯env系は有名ですよね。
言語のバージョン管理といえばこれです。
導入手順は公式の手順 通りなので省略します。
1点はまりどころがあります。
$GOPATHが変わらなくなってしまうという問題です。
本件に関しては以前、僕のブログで対処法を書いているので、
こちら を参考にしてみてください。
▼ go get（公式サイトに記載のある方法） （バージョン管理&amp;quot;ツール&amp;quot;とは言えませんが…）
本方法は公式サイト に 記載されている方法です。
$ go get golang.org/dl/goX.Y.Z $ goX.Y.Z download $ goX.Y.Z version go version goX.Y.Z linux/amd64 コマンド打つたびに、バージョンまで打つのがめんどくさいという方は、
bash や zsh の設定でエイリアスでも貼ってやればOKですね。
最新バージョンのインストール方法 冒頭で「基本的に最新バージョンに上げ続ければOK」と述べていたので、
最新バージョンのインストール方法についても言及しておきます。
特に新しいことはなくいろんなサイトで紹介されているのでさらっと流していきます。
▼ Homebrew $ brew install go 以上です。
標準出力にて「必要ならパスの設定してね」と言われます。
言われたとおりにやればOKです。
▼ ソースからのインストール こちらの方法はHomebrewでのインストールと比べると、少しややこしくなります。</description></item><item><title>【簡単まとめシリーズ】Go1.12からの変更点</title><link>https://tech.yyh-gl.dev/blog/changes-since-go-1-12/</link><pubDate>Mon, 03 Feb 2020 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/changes-since-go-1-12/</guid><description>簡単まとめシリーズ 『簡単まとめ』では、僕が記事や書籍で学んだ内容をメモ程度に簡単にまとめていきます📝
今回は Go1.12からの変更点 についてです。
The State of Go 2020 Twitterで『The State of Go 2020 』というタイトルのスライドを見つけました。
Go1.12から変わったところに焦点を当て、
Go1.13でどのような機能が追加されているのか、 Go1.14でどのような機能が追加される予定なのかまとめてあります。
今回は、完全主観で自分が興味のある内容をハイライトします〜😇
完全主観ハイライト ▼ 数値まわりの表現方法が増える https://speakerdeck.com/campoy/the-state-of-go-2020?slide=7 ▼ interfaceにおける関数の重複が許可される（例外あり） https://speakerdeck.com/campoy/the-state-of-go-2020?slide=17 ▼ エラーハンドリングが変わる https://speakerdeck.com/campoy/the-state-of-go-2020?slide=26 ▼ testingパッケージに CleanUp() が追加 https://speakerdeck.com/campoy/the-state-of-go-2020?slide=39 ▼ go modules https://speakerdeck.com/campoy/the-state-of-go-2020?slide=43 ▼ 配列・スライスにおける範囲外指定時のエラーが親切になった https://speakerdeck.com/campoy/the-state-of-go-2020?slide=50 ▼ deferが速くなる https://speakerdeck.com/campoy/the-state-of-go-2020?slide=51 ▼ json関連の処理が速くなる https://speakerdeck.com/campoy/the-state-of-go-2020?slide=52 ▼ 他にもいろいろ速くなる https://speakerdeck.com/campoy/the-state-of-go-2020?slide=53 ▼ GopherConの参加者が増えていく様子がえもい https://speakerdeck.com/campoy/the-state-of-go-2020?slide=64</description></item><item><title>GolangCI-Lintの設定ファイルを理解する</title><link>https://tech.yyh-gl.dev/blog/golangci-lint-custom-settings/</link><pubDate>Mon, 09 Dec 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/golangci-lint-custom-settings/</guid><description>DMM Advent Calendar 2019 本記事は DMM Advent Calendar 2019 の 9日目 の記事です。
私は現在、DMM.com の CDS というチームに所属し、
主にユーザレビュー基盤 のバックエンドを開発しています。
今回は、Go用Linterである GolangCI-Lint を軽く紹介した後に、
GolangCI-Lint のハマリポイントとその解決策である設定周りの話をします。
Linter 導入していますか？ 突然ですが、みなさんの開発環境には Linter が導入されているでしょうか？
私の所属するチームでは、
コーディング規約違反 および コンパイラでは見つけられないエラー を検知するために、
ローカルと CI において Linter を回すようにしています。
GoにおけるLinter Goの場合、Linterがデフォルトで用意されているうえに、
ライブラリとして公開されているものも多く存在します。
なかでも有名なものに以下のようなものがあります。
govet：GoデフォルトのLinter errcheck：ちゃんとエラーハンドリングしているかチェックしてくれる unused：未使用の定義をチェックしてくれる goimports：未使用のimportを消してくれたり、フォーマット修正してくれる gosimple：コードをシンプルにしてくれる しかしながら、多すぎるがゆえに どれを選択すればいいのか分からなくなりがちです。
加えて、導入する Linter が増えれば、その分だけ 導入・管理コストが増加 します。
この問題を解決してくれるツールが GolangCI-Lint です。
GolangCI-Lint 勉強会でもよく耳にするようになってきている＋多くの紹介記事があるので、
ここで詳しく説明する必要もないかもしれませんが、いちおう少しだけ触れておきます。
GolangCI-Lint とは、 GoのLinterを一元管理するためのツールです。
開発者は GolangCI-Lint を導入するだけで様々な Linter を実行することができます。
したがって、Linter の導入・管理コストが一気に下がりますし、</description></item><item><title>【Go+VCR】外部APIとの通信を保存してテストに使用する話</title><link>https://tech.yyh-gl.dev/blog/golang-vcr/</link><pubDate>Sun, 08 Dec 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/golang-vcr/</guid><description>Go3 Advent Calendar 2019 本記事は Go3 Advent Calendar 2019 の 8日目 の記事です。
ではでは、早速本題に入っていきます。
モック使ってますか？ みなさんモックコードは書いていますか？
テストコードを書いているなら、ほぼ必ず登場するあのモックです。
DB処理や関数のモックなどいろいろありますよね。
そんなモックコードですが、作ったり管理するのめんどくさいなぁとか思ってないですか？
モックだからといって雑なコードになっていませんか？
今回は、外部API通信のモック化にフォーカスし、
モックコードの作成・管理コストを軽減する VCR ライブラリ を紹介します。
VCR ライブラリ とは？ VCR（Video Cassette Recorder）とは、通信を保存し、再生するライブラリです。
つまり、APIリクエストの初回通信の内容を保存し、
次回以降その保存内容（レスポンス）を使いまわしてくれるというものです。
言い換えれば、外部APIのモックを自動生成してくれるということですね！
VCR ライブラリ in Go World Go用のVCRライブラリはいろいろあります 。
スター数が多いのは以下のものです。
go-vcr vcr-go govcr rpcreplay go-vcr および vcr-go，govcr の開発は盛んではないようです。
rpcreplay は google-cloud-go に包含されるパッケージであり、安心して使えそうです。
ただし、gRPC 用なので、その点は注意が必要です。
GoDocはこちら です。
今回は REST API を使って説明していくので、go-vcr を使用します。
go-vcr は、vcr-go と govcr よりスター数が多いです。
Ruby 製の vcr というライブラリがもとになっているようです。</description></item><item><title>【DeNA.go #3】Go活用事例やパフォーマンスチューニングの話聞いてきた</title><link>https://tech.yyh-gl.dev/blog/denago_3/</link><pubDate>Fri, 01 Nov 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/denago_3/</guid><description>DeNA.go #3 connpass ハッシュタグ：#DeNAgo 初参加です！
ビールとお弁当もらいました。
そしてなんとなんと k8sの技術書をいただいちゃいました！！！
もちろんステッカーもありましたよ👍
1. [Go活用事例]安全運転支援サービスを支える運用サイト 登壇者：@suhirotaka さん オートモーティブ事業本部スマートドライビング部システム開発グループ
スライド 主題 管理画面をGoで作成
Railsで作ってるものをGoで作る理由 実証実験時はスピード重視でRails 本サービスはパフォーマンス重視でGo 順次Goに書き換えていく
Goのフレームワーク GoのWAF（Web Application Framework）には
フルスタック・MVC ミニマル・高速 の2種類がある
この辺の話は、僕の旧ブログ にもいろいろ書いているのでどうぞー
DeNAではフルスタック・MVCを選択
GoにおけるフルスタックなWAF Beego：採用！ Revel：開発が止まってきている Iris：プロジェクトの運用がうまくいっていないようだった Beego フルスタックのMVCフレームワーク ORMまでついてる セッション管理、ロガー、キャッシュなどのライブラリがいろいろついてるけど、全てモジュール化されていて、部分的に他のライブラリを使うことができる Railsライクなフレームワーク Railsのbefore/after_actionに相当するものもある（Prepare(), Finish()） ライブラリ 使用ライブラリはこちら こういうの教えてくれるのめっちゃ嬉しい
ORM：GORM ロガー：logrus PDF生成：gopdf → 日本語もきれいにでるので最高にクール 画像生成：gg バーコード生成：Barcode 2. WebシステムのパフォーマンスとGo （写真撮り忘れた…）
登壇者：（@karupanerura） ゲーム・エンターテインメント事業本部ゲーム事業部Publish統括部共通基盤部アライアンスシステムグループ
スライド Webシステムにおけるパフォーマンスとは たくさんリクエスト処理できる かつ リソース消費が少ないのが システム全体で見たときの理想的なパフォーマンス
パフォーマンスチューニングのいろいろ 詳しいチューニング方法はこちら この中で初めて知ったものをピックアップ↓
◎ Server Sent Events HTTPコネクションを持続させる WebSocketより扱いが簡単らしい バファリングの諸注意 結局リソースを消費していることに違わないので、メモリ管理はちゃんとしないといけない</description></item><item><title>【mercari.go #11】エラーハンドリング ＋ singleflight ＋ ISUCON ベンチマーカー</title><link>https://tech.yyh-gl.dev/blog/mercarigo_11/</link><pubDate>Mon, 07 Oct 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/mercarigo_11/</guid><description>mercari.go #11 connpass： リンク ハッシュタグ： &amp;lt;code&amp;gt;#mercarigo&amp;lt;/code&amp;gt; 今回もお弁当とドリンクがありました！ありがたや
[追記：2019年10月12日]
[Mercari Engineering Blog](https://tech.mercari.com/entry/2019/10/11/160000) にて、本イベントの記事が公開されました。
発表資料が載せてあります。ありがたや🙏 1. About error handling in Go 登壇者：jd さん（@JehandadKamal）
資料 （正式に共有されたものでないので、発表の内容が少し異なります）
Errors are values ”Errors are values ” という考え方。
Goでよくあるエラー処理パターン エラーをラップしてより詳細な情報を付与する 専用構造体を作る スタックトレースを構成する ”Error is your domain” Domain Error Struct を作成する。
type Error struct { Op Op Kind Kind Serverity zapcore.ErrorLevel Err error } Op：Operation → 関数名とか Kind：エラー種別 → NotAvailable, NotFound といったもの Serverity：エラーレベル Err：エラー内容 上記のような構造体を作る理由 error を比較するときは、基本的に文字列の比較になるため取り回しが悪い → ”NotFound” という文字列を比較するとかとか</description></item><item><title>【Go同miniConf】Goの勉強会に参加してきた話</title><link>https://tech.yyh-gl.dev/blog/godo_miniconf/</link><pubDate>Tue, 06 Aug 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/godo_miniconf/</guid><description>概要 CyberAgent ＆ merpay が共催したGoのイベント
Connpass情報 ハッシュタグ：#godo_miniconf （写真撮るの忘れた…）
以下、発表まとめ
1. マイクロサービスとMonoRepo 登壇者：江頭 宏亮さん（@_hiro511） 発表スライド リポジトリ管理について WinTicket というサービス開発・運用中
36個のマイクロサービスで動いている
マルチリポジトリ：マイクロサービスごとにリポジトリが別れている モノリポジトリ：ひとつのリポジトリ。WinTicket ではこっち モノリポジトリ Google, FB, Tiwtter, Uberが採用 メリット 依存管理をシンプルにできる マルチリポジトリの場合、複数のリポジトリに変更を加える必要があるし、変更を取り込むのが面倒 モノレポだとすべてのコードが一箇所にあるので変更が楽 一貫性のある変更 複数のサービスにまたがる変更においても、アトミックなコミットが可能 コードの共有と再利用が用意 common ディレクトリがあればできる 大きなリファクタリングが容易 ビルドとテストを効率良くしたいという モノリポジトリだと、ビルドとテストに時間がかかる ので、効率よくビルドとテストしたい
Bazel（ベイゼル）：ビルド・テストツール Go, Andoroid, iOSなど様々な言語に対応 Googleが使っている（Googleの自社ツールがOSS化） 必要箇所だけビルド・テストする 速い スケーラブル 拡張可能 StarDarkという独自言語で設定定義 WinTicketではDockerビルドもこれ Go with Bazel Bazel のインストール by brew WORKSPACEファイルの作成 外部の依存関係を記述 BUILDファイルを作成 ビルド方法を示したもの Gazzelを利用して自動生成可能 ディレクトリ構成例
. ├BUILD.bazel ├WORKSPACE └cmd └main.go Gazzelは Go Modules と dep に対応 go.</description></item><item><title>【mercari.go #8】メルカリのGoに関する勉強会メモ</title><link>https://tech.yyh-gl.dev/blog/mercari_go/</link><pubDate>Sat, 15 Jun 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/mercari_go/</guid><description>mercari.go #8 connpass： リンク ハッシュタグ： &amp;lt;code&amp;gt;#mercarigo&amp;lt;/code&amp;gt; 独自ルール： 懇親会のGルール 懇親会のときに登壇者を囲んでもいいけど、自分たち以外にもう一人入ってこれるスペースを常に開けておこうねっていうルール。とてもよい！ 雰囲気 ビール以外にもおいしそうなご飯もありましたが、写真を撮るの忘れ…
以降、自分用のメモを書き連ねます。
詳細はスライドの方をご覧ください。
1. Goで学ぶKnative 登壇者： @toshi0607 さん
スライドリンク Knative Knative ＝ 最新のサーバーレス ワークロードをビルド、デプロイ、管理できる Kubernetes ベースのプラットフォーム AWS の Lmabda に近いことを k8s 上でできると解釈 登壇者含め、会場内で Knative を本番に導入している人はなし。
まだ時期尚早っぽい k8s のリソースを抽象化し、独自のPaaS/FaaSを構築するためのパーツを提供 k8s 上にのっかる。 Knative の構成 Serving Build Eventing 現状、一部、Istio に依存してしまっているので、Istioの導入が必要不可欠 登壇者は 機能実装に一層集中するための基盤 として注目している yml ファイルで定義した内容に基づいて コード生成 感想 終盤、 Knative の内部処理を コードリーディング していたのですが、
見入ってしまいメモを忘れていました。。。
Knative 初めて聞いたのですが、おもしろそうだなという感想。
k8s の勉強しないとな。
2. Gotham GoとGopherCon EUに参加してきました 登壇者： @tenntenn</description></item><item><title>【Go + レイヤードアーキテクチャー】DDDを意識してWeb APIを実装してみる</title><link>https://tech.yyh-gl.dev/blog/go_web_api/</link><pubDate>Fri, 14 Jun 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/go_web_api/</guid><description>更新（2019年10月30日） 初回投稿から3ヶ月経ちました。
この3ヶ月で新しく得た知見を基に、内容を一部アップデートしました。
今回やること Goのディレクトリ構成についていろいろと調べる中で、
こちらの資料 がとても分かりやすかったので、
今回はこちらを参考にGoでWeb APIを作っていきたいと思います。
加えて、本プロジェクトでは、DDD と レイヤードアーキテクチャー を取り入れます。
（内容はほぼレイヤードアーキテクチャになってしまいましたが…）
DDD については、「DDD を Go とレイヤードアーキテクチャでやるなら、こんな感じかな？」という個人の見解レベルです。
パッケージ構成の参考になれば幸いです。
（ですので、ドメインモデルは重度のドメイン貧血症に陥っていますｗ）
釣りタイトルみたいになっちゃっててすみません🧝‍♀️
環境 MacOS Mojave 10.14.6 Go 1.12.5 なお、今回は、Gin や Mux などといったフレームワークは使わず、
httprouter のみで薄く作っていこうと思います。
Mux を使った実装は 僕の前のブログで紹介している のでよければどうぞ。
・ ・
・
では、早速本題に入っていきましょう。
採用アーキテクチャ：レイヤードアーキテクチャ 参考記事内 で紹介されているのは レイヤードアーキテクチャ をベースに いろいろカスタマイズされたものらしいです。
クリーンアーキテクチャに似たアーキテクチャだとか。
ユースケース層という呼び方はクリーンアーキテクチャ由来ですね。
DDD の文脈だと アプリケーション層 と呼ばれますが、
アプリケーションって意味が広くて分かりづらいので、
本プロジェクトでは ユースケース という単語を使用します。
とりあえず、今回はスライドページ19で紹介されているディレクトリ構成に従って、 DDD を意識して Web API を実装していこうと思います。
（意識だけして、実践できずに終わりましたが😇）
レイヤードアーキテクチャ における各層の依存関係 について説明します。
依存関係の図は下記のとおりです。
矢印は依存の方向を示しています。</description></item><item><title>【goenv】GOPATH が変わらないときの対処法</title><link>https://tech.yyh-gl.dev/blog/gopath/</link><pubDate>Thu, 13 Jun 2019 09:00:00 +0900</pubDate><guid>https://tech.yyh-gl.dev/blog/gopath/</guid><description>GOPATH が変わらない… 今日こんな現象に遭遇した。
$ export GOPATH=/Users/yyh-gl/workspaces/Go $ echo $GOPATH /Users/yyh-gl/workspaces/Go $ go env GOPATH /Users/yyh-gl/go/1.12.5 GOPATH が書き換わらない。
解決方法 社内Slack で適当につぶやいたら、同期が助けてくれた（神）
画像にある Qiita のリンクが こちら ちなみに僕の環境の goenv は バージョン 1.12.5 だったので、2系に上げなくても発生する模様。
（追記：19/06/14）またまた同期が教えてくれました。
こちらの記事 によると、 goenv による管理は バージョン 1.12 からとのこと。
結論：goenv が GOPATH を管理しようとしてた
goenv の管理から外してやるには GOENV_DISABLE_GOPATH=1 にしてやればOK。
僕は zshrc に以下のとおり追記しました。
export GOENV_DISABLE_GOPATH=1
（zshrc の読み込み直しを忘れずに）
結果 $ go env GOPATH /Users/yyh-gl/workspaces/Go 変わった。よかった</description></item></channel></rss>