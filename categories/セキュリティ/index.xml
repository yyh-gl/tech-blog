<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>セキュリティ on yyh-gl's Tech Blog</title><link>https://yyh-gl.github.io/tech-blog/categories/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/</link><description>Recent content in セキュリティ on yyh-gl's Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Wed, 21 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://yyh-gl.github.io/tech-blog/categories/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/index.xml" rel="self" type="application/rss+xml"/><item><title>【Backend Engineer’s meetup】メルカリ社主催 バックエンダーのための Meetup イベント行ってきた</title><link>https://yyh-gl.github.io/tech-blog/blog/mercari_meetup_for_backend_engineers_1/</link><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><guid>https://yyh-gl.github.io/tech-blog/blog/mercari_meetup_for_backend_engineers_1/</guid><description>Backend Engineer’s meetup ~マイクロサービスにおける認証認可基盤~ connpass ハッシュタグ：#merpay_meetup メルカリさん恒例のオリジナルドリンクもらいました
1. マイクロサービスの内部通信における認証について 登壇者：@pospome さん
スライド（日本語が消えてしまっていますが、ダウンロードしたら見れました）
上記スライドの簡易メモ アカウント管理とログイン処理はそれぞれのチームに任せている
SubjectID という 全サービス共通のID に変換して扱う メルカリでは、OIDCベースの認可の仕組みを採用
RFCに書いてあるものと大差ないので、今回は マイクロサービスの内部通信における認証 について話す 全サービスは Gatwway を経由
Gateway から Authority Service にくる Authority Service を認証基盤チームが管理
外部からのリクエスト検証と内部通信用のトークンを生成している 内部トークンは毎リクエストごとに生成
マイクロサービス間で使用されるトークンはリクエスト単位で同一 内部トークン用のSDKを提供
Golangのみ対応 SDKを使うといろいろとよしなにしてくれる クレームをいい感じに取得 SubjectID のパースとかをいい感じにしてくれる マイクロサービスはバッチのためのエンドポイントをもつことがあるので、Gatewayによってユーザが直接叩くことがきない環境を作れるのはメリットとなる</description></item><item><title>【OAuth 2.0 / OIDC】アクセストークンとIDトークンの違い ＋ OIDC誕生の歴史</title><link>https://yyh-gl.github.io/tech-blog/blog/id_token_and_access_token/</link><pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate><guid>https://yyh-gl.github.io/tech-blog/blog/id_token_and_access_token/</guid><description>はじめに Web API のセキュリティ周りについて調べていると、
「OAuth 2.0」や「OpenID Connect」という単語をよく見かけると思います。
さらに調べると、「アクセストークン」と「IDトークン」という単語に出会いました。
しかし、この2つのトークンの違いについて、
いまいち理解ができていなかったので、今回は両者の違いを調べてみました。
加えて、トークンについて調べる中で、
OpenID Connectが生まれた経緯も知ることができたのでメモしておきます。
2つのトークンの違い アクセストークン と IDトークン、両者は役割が大きく異なります。
アクセストークン：認可（リソースへのアクセスコントロール＝あるリソースへの権限（readやwriteなど）を持っているかどうか確認すること） IDトークン：認証（その人が誰かを確認すること） 名前のままでした。
認可に使うためのいろいろな情報が詰まっているのがアクセストークンで、 認証に使うためのいろいろな情報が詰まっているのがIDトークンです。
OpenID Connectが生まれた経緯 OAuth 2.0およびOpenID Connectについて調べていると、
「OpenID Connect は OAuth 2.0 を拡張した仕様」であるという記述を見かけました。
どうしてOpenID Connectが必要になったのか、
この辺の経緯について述べていきます。
OAuth 2.0 は 認可 の仕組み まずは、OAuth 2.0について見ていきます。
OAuth 2.0 は 認可 の仕組みであり、 認証 の仕組みではない
のですが、実際にはOAuth 2.0を認証用途で使っているシステムは多く存在します。
OAuth 2.0 で認証を行うことの問題点については、
こちら の記事に詳しく書いてあります。
上記記事より、OAuth 2.0 による認証の問題点は、</description></item></channel></rss>