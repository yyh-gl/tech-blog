<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>アーキテクチャ on yyh-gl's Tech Blog</title><link>https://yyh-gl.github.io/tech-blog/categories/%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3/</link><description>Recent content in アーキテクチャ on yyh-gl's Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Tue, 18 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://yyh-gl.github.io/tech-blog/categories/%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3/index.xml" rel="self" type="application/rss+xml"/><item><title>【DDD】集約とトランザクション境界について調べたことメモ</title><link>https://yyh-gl.github.io/tech-blog/blog/ddd-aggregates-transaction/</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://yyh-gl.github.io/tech-blog/blog/ddd-aggregates-transaction/</guid><description>簡単まとめシリーズ 今回は 集約とトランザクション境界 について、
自分のわからないところを調べたので、メモとして残しておきます。
集約 集約の説明を『ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本』から拝借すると、
「データを変更するための単位として扱われるオブジェクトの集まりを集約といいます」とのこと。
↓ もうすこし具体的に言うと
DDDではエンティティと値オブジェクトというものがありますが、
値オブジェクトを直接触らず、 エンティティ経由でしか変更しないようにするというものですね。
このような制限をかけることで、
ひとまとまりにされたオブジェクト間で維持されるべき不変条件を守ることができます。
トランザクション境界 基本的な考えとしては、集約ごとにトランザクションを貼ります。
↑この基本を守るためにも、理想としては正しいモデリングにより、
正しいトランザクション境界を見つけることが大事です。
正しいトランザクション境界を見つけることは、不用意に大きなDBロックの発生を防止します。
しかしながら、集約をまたいでトランザクション制御したくなるときもあります。
→ 参考例
こういうときにどうするか、上記リンクでもいくつかの方法が挙げられています。
他のサイトも調べてみましたが、だいたい同じような方法が出てきました。
結果整合性 主流っぽい いろいろなサイト、書籍の中で紹介されていました 整合性を担保するための仕組みづくりが必要 整合性をチェックするためのバッチ など 集約をまたいでトランザクションを貼る 下記理由のためにあまり推奨されない ロック範囲が大きくなってしまう 守るべき「データの一貫性の境界」をコード上で表現できなくなる 参考サイト 複数の集約をさらにまとめた集約をつくる ロック範囲が大きくなってしまうため、あまり推奨されない 結果整合性 結果整合性については、
『ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本』の 12章3説「集約の大きさと操作の単位」で言及されているので、もう少しだけ詳しく調べました。</description></item><item><title>【Golang + レイヤードアーキテクチャー】DDD を意識して Web API を実装してみる</title><link>https://yyh-gl.github.io/tech-blog/blog/go_web_api/</link><pubDate>Fri, 14 Jun 2019 00:00:00 +0000</pubDate><guid>https://yyh-gl.github.io/tech-blog/blog/go_web_api/</guid><description>更新（2019年10月30日） 初回投稿から3ヶ月経ちました。
この3ヶ月で新しく得た知見を基に、内容を一部アップデートしました。
今回やること Golang のディレクトリ構成についていろいろと調べる中で、
こちらの資料 がとても分かりやすかったので、
今回はこちらを参考に Golang で Web API を作っていきたいと思います。
加えて、本プロジェクトでは、DDD と レイヤードアーキテクチャー を取り入れます。
（内容はほぼレイヤードアーキテクチャになってしまいましたが…）
DDD については、「DDD を Golang とレイヤードアーキテクチャでやるなら、こんな感じかな？」という個人の見解レベルです。
パッケージ構成の参考になれば幸いです。
（ですので、ドメインモデルは重度のドメイン貧血症に陥っていますｗ）
釣りタイトルみたいになっちゃっててすみません🧝‍♀️
環境 MacOS Mojave 10.14.6 Golang 1.12.5 なお、今回は、Gin や Mux などといったフレームワークは使わず、
httprouter のみで薄く作っていこうと思います。
Mux を使った実装は 僕の前のブログで紹介している のでよければどうぞ。
・ ・
・
では、早速本題に入っていきましょう。
採用アーキテクチャ：レイヤードアーキテクチャ 参考記事内 で紹介されているのは レイヤードアーキテクチャ をベースに いろいろカスタマイズされたものらしいです。
クリーンアーキテクチャに似たアーキテクチャだとか。
ユースケース層という呼び方はクリーンアーキテクチャ由来ですね。
DDD の文脈だと アプリケーション層 と呼ばれますが、
アプリケーションって意味が広くて分かりづらいので、
本プロジェクトでは ユースケース という単語を使用します。
とりあえず、今回はスライドページ19で紹介されているディレクトリ構成に従って、 DDD を意識して Web API を実装していこうと思います。</description></item><item><title>【エリック・エヴァンスのドメイン駆動設計】DDD入門 Part 1</title><link>https://yyh-gl.github.io/tech-blog/blog/evans_ddd_1/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://yyh-gl.github.io/tech-blog/blog/evans_ddd_1/</guid><description>DDD の勉強始めます 新卒研修を受ける中で DDD が出てきて、勉強したくなったので、
『エリック・エヴァンスのドメイン駆動設計』（エリック・エヴァンス著，今関 剛 監訳，和智 右桂、牧野 祐子 訳）を読んでいこうと思います。
今回は第1部「ドメインモデルを機能させる」の 1章 と 2章 をまとめます。
注意： 僕の理解をそのままメモとして書き連ねていきます。
したがって、誤った理解もあると思うので、そのときはDMとかでご指摘お願いします！
1章 知識をかみ砕く ソフトウェアを作るときに、はじめから対象を十分に理解している開発者などいない。
対象 ＝ これから作るソフトウェアで実現する作業 ＝ ドメイン
したがって、対象について詳しい人（ドメインエキスパート）と開発者で 十分に話し合って理解を深めることが重要である。
理解したことはモデルとして書き出す。 そして、ドメインエキスパートは足りないところがあれば追加で説明する。
開発者は分からないところがあれば質問する。
上記工程を何度も繰り返し、その都度得た知識をモデルに落とし込んでいく。
→ 継続的学習（継続的学習は開発が始まった後でも行う）
はじめから対象を如実に表したモデルを作れることは滅多にない。
ドメインエキスパート と 開発者 では見ている視点が違うので少し話を聞いたぐらいで 完璧なモデルを作ることができないのは当たり前である。
だからこそ、対話を通して、互いに疑問点や不要な点を洗い出し、洗練する必要がある。
これが 知識のかみ砕き である。
1章 まとめ ドメインエキスパートと開発者が話し合ってドメインをモデルに落とし込んでいく 用語の説明や不足点の追加など とにかく話す ドメイン：ソフトウェア化する対象（業務やサービスなど、ソフトウェア化の対象となりうる万物） 一発で完璧なモデリングはできないから、継続的に改善していく 2章 コミュニケーションと言語の使い方 ドメインエキスパートが使う専門用語を開発者は理解できないし、
開発者が使う専門用語をドメインエキスパートは理解できない。
ドメインエキスパートと開発者の両者が同じ意味だと思って使っていたとしても たいていの場合、差異がある。
このような差異があると 通訳 が必要となる。
通訳はコミュニケーションを鈍らせ、知識のかみ砕きを沈滞させる。
共通言語としてのモデル 通訳をなくすために、 モデルを言語の骨格として使用 する。</description></item></channel></rss>