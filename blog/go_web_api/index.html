<!doctype html><html lang=ja><head><meta charset=utf-8><title>【Golang + レイヤードアーキテクチャー】DDD を意識して Web API を実装してみる - yyh-gl's Tech Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=apple-touch-icon sizes=180x180 href="/tech-blog/favicon/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/tech-blog/favicon/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/tech-blog/favicon/favicon-16x16.png?v=1"><link rel=manifest href="/tech-blog/favicon/site.webmanifest?v=1"><link rel=mask-icon href="/tech-blog/favicon/safari-pinned-tab.svg?v=1" color=#ffffff><link rel="shortcut icon" href="/tech-blog/favicon/favicon.ico?v=1"><meta name=msapplication-config content="/tech-blog/favicon/browserconfig.xml?v=1"><meta name=msapplication-TileColor content="#ffffff"><meta name=theme-color content="#ffffff"><meta name=generator content="Hugo 0.79.1"><meta property="og:site_name" content="yyh-gl's Tech Blog"><meta property="og:title" content="【Golang + レイヤードアーキテクチャー】DDD を意識して Web API を実装してみる"><meta property="og:description" content="2019/10/30 に内容を一部更新しました"><meta property="description" content="2019/10/30 に内容を一部更新しました"><meta property="og:url" content="https://yyh-gl.github.io/tech-blog/blog/go_web_api/"><meta property="og:type" content="article"><meta property="og:image" content="https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/featured.webp"><meta property="og:image:alt" content="featured"><link rel=stylesheet href=/tech-blog/css/bundle.min.14e3564baeabdfcefc68e1825d12ece50580d07801c0ce92815b1f3eb5e97bf1.css integrity="sha256-FONWS66r3878aOGCXRLs5QWA0HgBwM6SgVsfPrXpe/E="><link rel=stylesheet href=/tech-blog/css/add-on.css><link rel=stylesheet href=/tech-blog/css/prism.css><script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js></script><script src=/tech-blog/js/vue.min.js></script><script src=/tech-blog/js/good-counter.js defer></script></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/tech-blog/ class=nav>Blog</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=/tech-blog/ class="nav link"><i class="fa fa-home"></i>Home</a>
<a href=/tech-blog/about/ class="nav link"><i class="far fa-id-card"></i>About</a>
<a href=/tech-blog/blog/ class="nav link"><i class="far fa-newspaper"></i>Blog</a>
<a href=/tech-blog/categories/ class="nav link"><i class="fas fa-sitemap"></i>Categories</a></menu>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav></header><div id=wrapper><section id=site-intro><a href=/tech-blog/><img src=https://yyh-gl.github.io/tech-blog/img/main/logo.webp class=circle width=80 alt="yyh-gl's icon"></a><header><h1>yyh-gl's Tech Blog</h1></header><main><p>技術ネタ中心のブログです。主な扱いはバックエンド技術と設計です。</p></main><footer><ul class=socnet-icons><li><a href=//github.com/yyh-gl target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//twitter.com/yyh_gl target=_blank rel=noopener title=Twitter class="fab fa-twitter"></a></li><li><a href=//speakerdeck.com/yyh_gl target=_blank title="Speaker Deck" class="fab fa-speaker-deck"></a></li></ul></footer></section><main id=site-main><article class=post><header><div class=title><h2><a href=/tech-blog/blog/go_web_api/>【Golang + レイヤードアーキテクチャー】DDD を意識して Web API を実装してみる</a></h2><p>2019/10/30 に内容を一部更新しました</p></div><div class=meta><time datetime="2019-06-14 00:00:00 +0000 UTC">2019-06-14</time><p>yyh-gl</p><p>5 分で読めます</p></div></header><div id=socnet-share></div><div class=content><a href=/tech-blog/blog/go_web_api/ class=image style="--bg-image: url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/featured.webp')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/featured.webp alt=featured></a><h1 id=更新2019年10月30日>更新（2019年10月30日）</h1><p>初回投稿から3ヶ月経ちました。<br>この3ヶ月で新しく得た知見を基に、内容を一部アップデートしました。</p><h1 id=今回やること>今回やること</h1><p>Golang のディレクトリ構成についていろいろと調べる中で、<br><a href=https://www.slideshare.net/pospome/go-80591000 target=_blank rel="noopener noreferrer">こちらの資料</a>
がとても分かりやすかったので、<br>今回はこちらを参考に Golang で Web API を作っていきたいと思います。</p><br><p>加えて、本プロジェクトでは、DDD と レイヤードアーキテクチャー を取り入れます。<br>（内容はほぼレイヤードアーキテクチャになってしまいましたが…）</p><p>DDD については、「DDD を Golang とレイヤードアーキテクチャでやるなら、こんな感じかな？」という個人の見解レベルです。<br>パッケージ構成の参考になれば幸いです。<br>（ですので、ドメインモデルは重度のドメイン貧血症に陥っていますｗ）</p><p>釣りタイトルみたいになっちゃっててすみません🧝‍♀️</p><h2 id=環境>環境</h2><ul><li>MacOS Mojave 10.14.6</li><li>Golang 1.12.5</li></ul><p>なお、今回は、Gin や Mux などといったフレームワークは使わず、<br>httprouter のみで薄く作っていこうと思います。</p><p>Mux を使った実装は <a href=https://yyh-gl.hatenablog.com/entry/2019/02/08/195310 target=_blank rel="noopener noreferrer">僕の前のブログで紹介している</a>
のでよければどうぞ。</p><br>・<p>・</p><p>・</p><p>では、早速本題に入っていきましょう。</p><h1 id=採用アーキテクチャレイヤードアーキテクチャ>採用アーキテクチャ：レイヤードアーキテクチャ</h1><p><a href=https://www.slideshare.net/pospome/go-80591000 target=_blank rel="noopener noreferrer">参考記事内</a>
で紹介されているのは <u>レイヤードアーキテクチャ</u> をベースに<br>いろいろカスタマイズされたものらしいです。</p><p>クリーンアーキテクチャに似たアーキテクチャだとか。</p><hr><p>ユースケース層という呼び方はクリーンアーキテクチャ由来ですね。</p><p>DDD の文脈だと アプリケーション層 と呼ばれますが、<br>アプリケーションって意味が広くて分かりづらいので、<br>本プロジェクトでは ユースケース という単語を使用します。</p><hr><p>とりあえず、今回はスライドページ19で紹介されているディレクトリ構成に従って、<br><u>DDD を意識して</u> Web API を実装していこうと思います。</p><p>（意識だけして、実践できずに終わりましたが😇）</p><br><p>レイヤードアーキテクチャ における各層の依存関係 について説明します。</p><p>依存関係の図は下記のとおりです。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/architecture.png width=600><p>矢印は依存の方向を示しています。<br>例えば、上図だと Handler層 は UseCase層 の処理を利用することを意味します。</p><br><p>一般的なレイヤードアーキテクチャだと、上から下に一方向に依存します。<br>しかし、今回は、Infra層が Domain層に依存しています。<br>このあたりはオニオンアーキテクチャーやクリーンアーキテクチャと同じやり方ですね。</p><p>さきほどの図を視点を変えて見てみます。（下記の図）<br>今回採用したアーキテクチャは、<br>オニオンアーキテクチャーやクリーンアーキテクチャのように、<br>依存が中心方向に <u>のみ</u> 向いていることがわかります。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/dependency_direction1.png width=600><p><u>すべての依存が中心に向かっているこの状態が理想です</u>。</p><p>（Handler層と Infra層が一緒の層みたいになっていますが、全くの別物です。うまく分離して描けず、こうなりました。ご注意を）</p><hr><p>依存関係について、もう少し述べておくと、<br>基本的に依存はひとつ下の層までに抑えておくべきのようです。</p><p>ただし、簡略化のために2つ下の層まで依存している例もあるので、<br>そこはチームとして同意が取れていれば良いのではないでしょうか。</p><hr><br><p>ここで、ユーザから APIリクエスト があった場合を考えてみます。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/dependency_direction2.png width=600><p>ユーザからのリクエストは Handler で受け取られ、 UseCase を使って処理が行われます。<br>さらに、UseCase は Domain を使って処理を行います。<br>ここまでは処理が中心に進んでいる、つまり依存は中心に向かって発生しています。</p><p>しかし、たいていのサービスって DB を使用しますよね。<br>つまり、ユースケースからドメインを介して、Infra を利用することになります。</p><p>UseCase → Domain → Infra</p><p>…依存が外側を向いてしまいました。<br>これは許されていません。ではどうするか。</p><p><u><a href=https://medium.com/eureka-engineering/go-dependency-inversion-principle-8ffaf7854a55 target=_blank rel="noopener noreferrer">依存性逆転の法則</a></u> を使います。</p><br><p><u>依存性逆転の法則 とは、 interfaceを利用して、依存の方向を逆にすること</u> です。</p><p>もう少し詳しく説明します。<br>まず、 ① Domain層 において、 DB とのやりとりを interface で定義しておきます。<br>interface （後ほどコード内にて BookRepository として出てきます） 自体は実装を持たないので、<br>どこにも依存していません。</p><p>次に、 ② Infra層 から Domain層 に定義した interface （後ほどコード内にて BookPersistence として出てきます） を実装します。</p><br><p>①, ② の2ステップを踏むことで、まず Domain は interface に対して 処理をお願いするだけでよくなります。
先ほども言ったとおり interface は 実装を持たないので依存関係はありません。</p><p>interface 自体は実装を持ちませんが、<br>Infra が interface の実装を行っているので、ちゃんとDBアクセスして処理を行うことができます。</p><p>ここで、 Infra は interface を実装しているので、依存が interface 、すなわち Domain に向いています。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/dependency_direction3.png width=600><p>依存性が逆転し、すべての依存関係が中心に向かうようになりましたね。</p><br><p>ここはとっつきづらいところなので、まだいまいち理解できないかもしれません。</p><p>以降、実際のコードを紹介していくので、コードに落とし込みながら考えてみてください。</p><h1 id=完成物>完成物</h1><p>完成物に関しては <a href=https://github.com/yyh-gl/go-api-server-by-ddd target=_blank rel="noopener noreferrer">こちら</a>
に置いておきます。</p><h2 id=api-一覧>API 一覧</h2><p>書籍管理システム の API を想定</p><ul><li>書籍一覧 取得</li><li>書籍詳細 取得</li><li>書籍 追加</li><li>書籍 貸出</li><li>書籍 返却</li></ul><br><p>ディレクトリ構成はこんな感じです。</p><pre class=line-numbers><code class=language-tree>api-server-with-go-kit-and-ddd
├── cmd
│   └── api
│       └── main.go  // サーバ起動したり、依存注入、ルーティングを行う
├── domain
│   └── blog.go
├── go.mod
├── go.sum
├── handler
│   └── rest // RESTful API 用のハンドラー
│       └── blog.go
├── infra
│   └── blog.go
└── usecase
    └── blog.go
</code></pre><h1 id=書籍一覧を取得するapiを作る>書籍一覧を取得するAPIを作る</h1><h2 id=domain-層>Domain 層</h2><p>まずは、<code>/domain/model</code> に書籍モデルを作っていきます。</p><p><u>Domain層 はシステムが扱う業務領域に関するコードを置くところです。</u></p><p>よって、「書籍」 がどういうものなのかモデルという形で定義します。</p><p><code>/domain/model/book.go</code></p><pre class=line-numbers><code class=language-go>package model

import &quot;time&quot;

// Book : Book を表すドメインモデル
// !! 重度のドメイン貧血症です !!
type Book struct {
	Id       int64
	Title    string
	Author   string
	IssuedAt time.Time
}
</code></pre><p>冒頭でも述べたとおり、みごとなドメイン貧血症っぷりです。</p><p>ちゃんと 値オブジェクトを使ったりして、ごりごり DDD していきたいですが、今回は…省きます🙇‍♂️</p><br><p>次に、<code>/domain/repository/book.go</code> を作っていきます。</p><p>今回、 <u>リポジトリでやることを簡単に言うと、 DB や KVS などで行う CRUD処理 の定義です。</u><br>ただし、<u>Domain層には技術的関心事を持ち込まない</u> というルールがあるため、<br>ここでは interface を定義するだけです。</p><p>実装は、後述する infra で行います。<br>（<u>Infra層 は技術的関心事を扱う層です</u>）</p><p>リポジトリについてちゃんと知りたい方は、<br><a href=https://blog.fukuchiharuki.me/entry/use-repository-and-dao-according-to-the-purpose target=_blank rel="noopener noreferrer">こちら</a>
が参考になると思います。</p><br><p><code>/domain/repository/book.go</code></p><pre class=line-numbers><code class=language-go>package repository

import (
	&quot;context&quot;

	&quot;github.com/yyh-gl/go-api-server-by-ddd/domain/model&quot;
)

// BookRepository : Book における Repository のインターフェース
//  -&gt; 依存性逆転の法則により infra 層は domain 層（本インターフェース）に依存
type BookRepository interface {
	GetAll(context.Context) ([]*model.Book, error)
}
</code></pre><p>今は 全ての書籍を取得する関数 <code>GetAll()</code> のみ定義します。</p><br><p>ここで、はじめに示した 依存関係の図 を思い出してください。</p><p>今定義した Domain層 は他の層のコードを一切利用していません。<br>つまり、<u>下図の赤枠の中で依存関係が完結しています</u>。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/dependency_domain.png width=600><h2 id=infra-層>Infra 層</h2><p>さきほど述べたとおり、<u>Infra層 は技術的関心事を扱う層です。</u></p><p>ここでさっき定義した repository の処理を実装します。</p><p><code>/infra/persistence/book.go</code></p><pre class=line-numbers><code class=language-go>package persistence

// repository という名前にしたいが domain 配下の repository とパッケージ名が被ってしまうため persistence で代替

import (
	&quot;context&quot;
	&quot;time&quot;

	&quot;github.com/yyh-gl/go-api-server-by-ddd/domain/model&quot;
	&quot;github.com/yyh-gl/go-api-server-by-ddd/domain/repository&quot;
)

type bookPersistence struct{}

// NewBookPersistence : Book データに関する Persistence を生成
func NewBookPersistence() repository.BookRepository {
	return &amp;bookPersistence{}
}

// GetAll : DB から Book データを全件取得（BookRepository インターフェースの GetAll() を実装したもの）
//  -&gt; 本来は DB からデータを取得するが、簡略化のために省略（モックデータを返却）
func (bp bookPersistence) GetAll(context.Context) ([]*model.Book, error) {
	book1 := model.Book{}
	book1.Id = 1
	book1.Title = &quot;DDDが分かる本&quot;
	book1.Author = &quot;たろうくん&quot;
	book1.IssuedAt = time.Now().Add(-24 * time.Hour)

	book2 := model.Book{}
	book2.Id = 2
	book2.Title = &quot;レイヤードアーキテクチャが分かる本&quot;
	book2.Author = &quot;はなこさん&quot;
	book2.IssuedAt = time.Now().Add(-24 * 7 * time.Hour)

	return []*model.Book{&amp;book1, &amp;book2}, nil
}
</code></pre><p>なお、 実際には DB にアクセスし、データを持ってくるようにします。<br>ここでは一旦モックデータを返すようにしておきます。</p><p>また、Persistence という単語がいきなり出てきましたが、これは Repository と同義です。<br>実際に <code>NewBookPersistence()</code> の中身を見ると Repository のインターフェースを返していると思います。<br>（<code>NewBookPersistence()</code>の詳細は後述）</p><p>本当は Repositoryという名前を使いたかったのですが、<br>Domain層と Infra層 でパッケージ名が被ってしまうため、やむなくこうしています。</p><br><p>先ほどと同様に 依存関係 を確認します。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/dependency_infra.png width=600><p>Infra層 は Domain層 で作った <code>/domain/repository/book.go</code> のインターフェース（BookRepository）を実装しています。<br></p><br><p>ここで、Golang に慣れていない方は、どこでインターフェースと関連づけてるの？<br>という疑問が生まれると思います。</p><p>答えは、 <code>NewBookPersistence()</code> です。<br>この関数の戻り値は インターフェース です。<br>したがって、17行目でreturnする bookPersistence がインターフェースを満たしていないとエラーとなります。<br>このようにして インターフェースを満たしているか否かを判別します。</p><p><code>NewBookPersistence()</code> をどこで使うかは後述します。</p><br><p>では、依存関係を見ていきます。<br>上述したとおり、Infra層 は Domain層 のインターフェースを満たすように作られているので、Domain層に依存しています。<br>Golang には implements とかないので分かりづらいですね。<br>でも、確かに依存しています。</p><h2 id=usecase-層>UseCase 層</h2><p><u>UseCase層 では、システムのユースケースを満たす処理の流れを実装します。</u></p><p>今回は単純な処理しかしないので、この層の存在価値が少し分かりづらくなってしまいます。</p><p>複雑なビジネスロジックがあるときは、この層の存在が効いてくると思います。</p><br><p>コードは以下のとおりです。</p><p><code>/usecase/book.go</code></p><pre class=line-numbers><code class=language-go>package usecase

import (
	&quot;context&quot;

	&quot;github.com/yyh-gl/go-api-server-by-ddd/domain/model&quot;
	&quot;github.com/yyh-gl/go-api-server-by-ddd/domain/repository&quot;
)

// BookUseCase : Book における UseCase のインターフェース
type BookUseCase interface {
	GetAll(context.Context) ([]*model.Book, error)
}

type bookUseCase struct {
	bookRepository repository.BookRepository
}

// NewBookUseCase : Book データに関する UseCase を生成
func NewBookUseCase(br repository.BookRepository) BookUseCase {
	return &amp;bookUseCase{
		bookRepository: br,
	}
}

// GetAll : Book データを全件取得するためのユースケース
//  -&gt; 本システムではあまりユースケース層の恩恵を受けれないが、もう少し大きなシステムになってくると、
//    「ドメインモデルの調節者」としての役割が見えてくる
func (bu bookUseCase) GetAll(ctx context.Context) (books []*model.Book, err error) {
	// Persistence（Repository）を呼出
	books, err = bu.bookRepository.GetAll(ctx)
	if err != nil {
		return nil, err
	}
	return books, nil
}
</code></pre><br><p>UseCase層 の依存関係も見てみましょう。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/dependency_usecase.png width=600><p>UseCase層 は <code>/domain/repository</code> を呼び出しています。<br>したがって、 UseCase層 は Domain層 に依存しています。</p><br><p><a href=https://www.slideshare.net/pospome/go-80591000 target=_blank rel="noopener noreferrer">参考にしている資料</a>
では、<br>UseCase層 をさらに input と output で切っていますが、複雑になりすぎると思い、省略しました。</p><h2 id=handler-層>Handler 層</h2><p>次に Handler層 です。</p><p><u>本プロジェクトにおける、Handler層 の役目は、HTTPリクエストを受け取り、UseCase を使って処理を行い、結果を返す</u> ことです。</p><p>ただし、本来の Handler層は HTTPリクエストに限った話ではありません。</p><p>外部にあるものがなんであれ、その差異を吸収して、ユースケースに伝えるのが役目です。</p><p>したがって、HTTP通信以外でも対応できるように、本プロジェクトでは <code>/handler/rest</code> というふうにディレクトリを切っています。<br>（RESTful API であることを明確にしてみました）<br>CLIを追加するなら <code>/handler/cli</code> というふうにディレクトリを切ればOK。</p><br><p>本プロジェクトのコード的には以下のようになります。</p><p><code>/handler/blog.go</code></p><pre class=line-numbers><code class=language-go>package rest

// Handler 層を変えるだけで、例えば CLI にも簡単に対応可能

import (
	&quot;encoding/json&quot;
	&quot;net/http&quot;
	&quot;time&quot;

	&quot;github.com/julienschmidt/httprouter&quot;
	&quot;github.com/yyh-gl/go-api-server-by-ddd/usecase&quot;
)

// BookHandler : Book における Handler のインターフェース
type BookHandler interface {
	Index(http.ResponseWriter, *http.Request, httprouter.Params)
}

type bookHandler struct {
	bookUseCase usecase.BookUseCase
}

// NewBookUseCase : Book データに関する Handler を生成
func NewBookHandler(bu usecase.BookUseCase) BookHandler {
	return &amp;bookHandler{
		bookUseCase: bu,
	}
}

// BookIndex : GET /books -&gt; Book データ一覧を返す
func (bh bookHandler) Index(w http.ResponseWriter, r *http.Request, pr httprouter.Params) {
	// request : 本 API のリクエストパラメータ
	//  -&gt; こんな感じでリクエストも受け取れますが、今回は使いません
	type request struct {
		Begin uint `query:&quot;begin&quot;`
		Limit uint `query:&quot;limit&quot;`
	}

	// bookField : response 内で使用する Book を表す構造体
	//  -&gt; ドメインモデルの Book に HTTP の関心事である JSON タグを付与したくないために Handler 層で用意
	//     簡略化のために JSON タグを付与したドメインモデルを流用するプロジェクトもしばしば見かける
	type bookField struct {
		Id       int64     `json:&quot;id&quot;`
		Title    string    `json:&quot;title&quot;`
		Author   string    `json:&quot;author&quot;`
		IssuedAt time.Time `json:&quot;issued_at&quot;`
	}

	// response : 本 API のレスポンス
	type response struct {
		Books []bookField `json:&quot;books&quot;`
	}

	ctx := r.Context()

	// ユースケースの呼出
	books, err := bh.bookUseCase.GetAll(ctx)
	if err != nil {
		// TODO: エラーハンドリングをきちんとする
		http.Error(w, &quot;Internal Server Error&quot;, 500)
		return
	}

	// 取得したドメインモデルを response に変換
	res := new(response)
	for _, book := range books {
		var bf bookField
		bf = bookField(*book)
		res.Books = append(res.Books, bf)
	}

	// クライアントにレスポンスを返却
	w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
	if err = json.NewEncoder(w).Encode(res); err != nil {
		// TODO: エラーハンドリングをきちんとする
		http.Error(w, &quot;Internal Server Error&quot;, 500)
		return
	}
}
</code></pre><br><p>依存関係は以下のとおりです。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/go_web_api/dependency_handler.png width=600><p>57行目で UseCase を使用するので、UseCase層に依存しています。</p><h2 id=maingo>main.go</h2><p>ここまでで、書籍に関する Handler, UseCase, Repository が用意できました。<br>最後に、<code>main.go</code> にて、これらの依存関係を定義してやることで、利用可能な状態にします。<br>（DI とかはやってません🙏）</p><p>このとき利用するのが、各層に用意されている <code>NewXxx()</code> という関数です。</p><p><code>NewXxx()</code> を使用して、Handler や UseCase, Repository を生成し、メソッドを実行できるようにします。</p><p><code>/cmd/api/main.go</code></p><pre class=line-numbers><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net/http&quot;

	&quot;github.com/julienschmidt/httprouter&quot;
	handler &quot;github.com/yyh-gl/go-api-server-by-ddd/handler/rest&quot;
	&quot;github.com/yyh-gl/go-api-server-by-ddd/infra/persistence&quot;
	&quot;github.com/yyh-gl/go-api-server-by-ddd/usecase&quot;
)

func main() {
	// 依存関係を注入（DI まではいきませんが一応注入っぽいことをしてる）
	// DI ライブラリを使えば、もっとスマートになるはず
	bookPersistence := persistence.NewBookPersistence()
	bookUseCase := usecase.NewBookUseCase(bookPersistence)
	bookHandler := handler.NewBookHandler(bookUseCase)

	// ルーティングの設定
	router := httprouter.New()
	router.GET(&quot;/api/v1/books&quot;, bookHandler.Index)

	// サーバ起動
	fmt.Println(&quot;========================&quot;)
	fmt.Println(&quot;Server Start &gt;&gt; http://localhost:3000&quot;)
	fmt.Println(&quot;========================&quot;)
	log.Fatal(http.ListenAndServe(&quot;:3000&quot;, router))
}
</code></pre><p>注目していただきたのが、17行目から19行目の処理です。<br>ここで、各層の <code>NewXxx()</code> の処理を使って依存関係を定義しています。</p><p>DI ライブラリを使うことで、よりスマートに書けると思いますが、<br>愚直にやるならこんな感じです。</p><h1 id=テスト>テスト</h1><p>ここまでの実装で 書籍一覧 取得リクエスト を送れるようになりました。</p><pre class=line-numbers><code class=language-bash>$ go run cmd/api/main.go
$ curl -X GET  http://localhost:3000/api/v1/books
</code></pre><p>上記コマンドを実行すると、<br>2つの書籍データが返ってくるはずです。</p><pre class=line-numbers><code class=language-json>{
  &quot;books&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;title&quot;: &quot;DDDが分かる本&quot;,
      &quot;author&quot;: &quot;たろうくん&quot;,
      &quot;issued_at&quot;: &quot;2019-10-29T02:22:09.264835+09:00&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;title&quot;: &quot;レイヤードアーキテクチャが分かる本&quot;,
      &quot;author&quot;: &quot;はなこさん&quot;,
      &quot;issued_at&quot;: &quot;2019-10-23T02:22:09.264841+09:00&quot;
    }
  ]
}
</code></pre><br><p>エンドポイントが一個しかなかったり、DB 接続してなかったりと、未完成なところが多いですが、<br>DDD や レイヤードアーキテクチャ が絡んできて、結構重い内容になってきたので、一旦ここで切ろうと思います。<br>後日、続編記事を出したいと思います。</p><h1 id=まとめ>まとめ</h1><p>レイヤードアーキテクチャがメインの話になりましたが、<br>アーキテクチャについて勉強中だったので、僕的にはちょうど良い勉強になりました。</p><p>今後は、エヴァンス本で「ドメイン知識をどのようにしてドメインモデルに落とし込んでいくのか」ってところを勉強していこうと思います。</p></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/tech-blog/categories/go/>Go</a></li><li><a class=article-terms-link href=/tech-blog/categories/web-api/>Web API</a></li><li><a class=article-terms-link href=/tech-blog/categories/%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3/>アーキテクチャ</a></li><li><a class=article-terms-link href=/tech-blog/categories/ddd/>DDD</a></li></ul><div><good-counter url=/tech-blog/blog/go_web_api/></good-counter></div></div></footer><div class=fix><a href="https://github.com/yyh-gl/tech-blog/issues/new?template=fix_proposal.md&assignees=yyh-gl&title=修正提案：『%e3%80%90Golang%20%2b%20%e3%83%ac%e3%82%a4%e3%83%a4%e3%83%bc%e3%83%89%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%83%bc%e3%80%91DDD%20%e3%82%92%e6%84%8f%e8%ad%98%e3%81%97%e3%81%a6%20Web%20API%20%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%97%e3%81%a6%e3%81%bf%e3%82%8b』">修正提案</a></div></article><div class=pagination><a href=/tech-blog/blog/mercari_go/ class="button left"><span>【mercari.go #8】メルカリの Golang に関する勉強会メモ</span></a>
<a href=/tech-blog/blog/gopath/ class="button right"><span>【goenv】GOPATH が変わらないときの対処法</span></a></div></main><section id=site-sidebar><section id=recent-posts><header><h1>最近の投稿</h1></header><article class=mini-post><a href=/tech-blog/blog/uncredible-codes-from-go-spec/ class=image style="--bg-image: url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/12/uncredible-codes-from-go-spec/featured.webp')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/12/uncredible-codes-from-go-spec/featured.webp alt=featured></a><header><h2><a href=/tech-blog/blog/uncredible-codes-from-go-spec/>The Go Programming Language Specificationで知った「こんなことできるだ」を紹介</a></h2><time class=published datetime="2020-12-08 00:00:00 +0900 +0900">2020-12-08</time></header></article><article class=mini-post><a href=/tech-blog/blog/support-webp/ class=image style="--bg-image: url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/11/support-webp/featured.webp')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/11/support-webp/featured.webp alt=featured></a><header><h2><a href=/tech-blog/blog/support-webp/>ブログの画像をWebPに変えた話とSafariで表示されない件について</a></h2><time class=published datetime="2020-11-26 13:50:31 +0900 +0900">2020-11-26</time></header></article><article class=mini-post><a href=/tech-blog/blog/go-switch-fallthrough/ class=image style="--bg-image: url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/10/go-switch-fallthrough/featured.webp')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/10/go-switch-fallthrough/featured.webp alt=featured></a><header><h2><a href=/tech-blog/blog/go-switch-fallthrough/>【Go】Switch文のfallthroughに関するまとめ</a></h2><time class=published datetime="2020-10-03 00:00:00 +0000 UTC">2020-10-03</time></header></article><footer><a href=/tech-blog/blog/ class=button>続きを見る</a></footer></section><section id=categories><header><h1><a href=/tech-blog/categories>Categories</a></h1></header><ul><li><a href=/tech-blog/categories/go/>go<span class=count>18</span></a><li><a href=/tech-blog/categories/%E5%8B%89%E5%BC%B7%E4%BC%9A/>勉強会<span class=count>6</span></a><li><a href=/tech-blog/categories/ddd/>ddd<span class=count>5</span></a><li><a href=/tech-blog/categories/advent-calendar/>advent-calendar<span class=count>4</span></a><li><a href=/tech-blog/categories/web-api/>web-api<span class=count>3</span></a><li><a href=/tech-blog/categories/web%E5%85%A8%E8%88%AC/>web全般<span class=count>3</span></a><li><a href=/tech-blog/categories/%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3/>アーキテクチャ<span class=count>3</span></a><li><a href=/tech-blog/categories/%E8%AA%AD%E6%9B%B8%E3%81%BE%E3%81%A8%E3%82%81/>読書まとめ<span class=count>3</span></a><li><a href=/tech-blog/categories/html/css/>html/css<span class=count>2</span></a><li><a href=/tech-blog/categories/react/>react<span class=count>2</span></a><li><a href=/tech-blog/categories/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/>セキュリティ<span class=count>2</span></a><li><a href=/tech-blog/categories/%E3%83%86%E3%82%B9%E3%83%88/>テスト<span class=count>2</span></a><li><a href=/tech-blog/categories/android/>android<span class=count>1</span></a><li><a href=/tech-blog/categories/aws/>aws<span class=count>1</span></a><li><a href=/tech-blog/categories/ci/cd/>ci/cd<span class=count>1</span></a><li><a href=/tech-blog/categories/ecs/>ecs<span class=count>1</span></a><li><a href=/tech-blog/categories/firebase/>firebase<span class=count>1</span></a><li><a href=/tech-blog/categories/github/>github<span class=count>1</span></a><li><a href=/tech-blog/categories/kotlin/>kotlin<span class=count>1</span></a><li><a href=/tech-blog/categories/lint/>lint<span class=count>1</span></a><li><a href=/tech-blog/categories/podcast/>podcast<span class=count>1</span></a><li><a href=/tech-blog/categories/rds/>rds<span class=count>1</span></a><li><a href=/tech-blog/categories/terraform/>terraform<span class=count>1</span></a><li><a href=/tech-blog/categories/typescript/>typescript<span class=count>1</span></a><li><a href=/tech-blog/categories/vue.js/>vue.js<span class=count>1</span></a><li><a href=/tech-blog/categories/%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%A0/>スクラム<span class=count>1</span></a><li><a href=/tech-blog/categories/%E3%83%81%E3%83%BC%E3%83%A0%E3%83%9E%E3%83%8D%E3%82%B8%E3%83%A1%E3%83%B3%E3%83%88/>チームマネジメント<span class=count>1</span></a><li><a href=/tech-blog/categories/%E3%83%9D%E3%82%A8%E3%83%A0/>ポエム<span class=count>1</span></a><li><a href=/tech-blog/categories/%E5%85%A5%E9%96%80/>入門<span class=count>1</span></a><li><a href=/tech-blog/categories/%E7%B0%A1%E5%8D%98%E3%81%BE%E3%81%A8%E3%82%81/>簡単まとめ<span class=count>1</span></a><li><a href=/tech-blog/categories/%E8%87%AA%E5%B7%B1%E7%B4%B9%E4%BB%8B/>自己紹介<span class=count>1</span></a></li></ul></section><section id=mini-bio><header><h1>About</h1></header><p>東京で働くソフトウェアエンジニアです。バックエンドがメインですが、フロントやインフラもさわっています。</p><footer><a href=/tech-blog/about class=button>もっと詳しく知る</a></footer></section></section><footer id=site-footer><ul class=socnet-icons><li><a href=//github.com/yyh-gl target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//twitter.com/yyh_gl target=_blank rel=noopener title=Twitter class="fab fa-twitter"></a></li><li><a href=//speakerdeck.com/yyh_gl target=_blank title="Speaker Deck" class="fab fa-speaker-deck"></a></li></ul><p class=copyright>© 2020 yyh-gl's Tech Blog<br>Theme: <a href=https://github.com/pacollins/hugo-future-imperfect-slim target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>A <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP port</a> | Powered by <a href=https://gohugo.io/ title=0.79.1 target=_blank rel=noopener>Hugo</a></p></footer><a id=back-to-top href=# class="fas fa-arrow-up fa-2x"></a><script src=/tech-blog/js/bundle.min.efc5f018aa147b6e1fc7458bc001223cb19bb1089277e3be6aba3fe7afb9a03e.js integrity="sha256-78XwGKoUe24fx0WLwAEiPLGbsQiSd+O+aro/56+5oD4="></script><script src=/tech-blog/js/add-on.js></script><script src=/tech-blog/js/prism.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-140914324-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></div></body></html>