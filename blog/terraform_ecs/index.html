<!doctype html><html lang=ja><head><meta charset=utf-8><title>【Terraform + ECS + RDS】Terraform で ECS環境構築してみた - yyh-gl's Tech Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=apple-touch-icon sizes=180x180 href="/tech-blog/favicon/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/tech-blog/favicon/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/tech-blog/favicon/favicon-16x16.png?v=1"><link rel=manifest href="/tech-blog/favicon/site.webmanifest?v=1"><link rel=mask-icon href="/tech-blog/favicon/safari-pinned-tab.svg?v=1" color=#ffffff><link rel="shortcut icon" href="/tech-blog/favicon/favicon.ico?v=1"><meta name=msapplication-config content="/tech-blog/favicon/browserconfig.xml?v=1"><meta name=msapplication-TileColor content="#ffffff"><meta name=theme-color content="#ffffff"><meta name=generator content="Hugo 0.94.2"><meta property="og:site_name" content="yyh-gl's Tech Blog"><meta property="og:title" content="【Terraform + ECS + RDS】Terraform で ECS環境構築してみた"><meta property="og:description" content="技術系ネタ中心のブログです。サーバサイドをメインとしたフルスタックエンジニアを目指しています。"><meta property="description" content="技術系ネタ中心のブログです。サーバサイドをメインとしたフルスタックエンジニアを目指しています。"><meta property="og:url" content="https://yyh-gl.github.io/tech-blog/blog/terraform_ecs/"><meta property="og:type" content="article"><meta property="og:image" content="https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/terraform_ecs/featured.webp"><meta property="og:image:alt" content="featured"><link rel=stylesheet href=/tech-blog/css/bundle.min.b3b210b14743bef0baf37fbaaa81e2f4cd1365a34bd4a475a59f83d587fd7edc.css integrity="sha256-s7IQsUdDvvC683+6qoHi9M0TZaNL1KR1pZ+D1Yf9ftw="><link rel=stylesheet href=/tech-blog/css/add-on.css><link rel=stylesheet href=/tech-blog/css/prism.css><script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js></script>
<script src=/tech-blog/js/vue.min.js></script>
<script src=/tech-blog/js/good-counter.js defer></script></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/tech-blog/ class=nav>Blog</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=/tech-blog/ class="nav link"><i class="fa fa-home"></i> Home</a>
<a href=/tech-blog/about/ class="nav link"><i class="far fa-id-card"></i> About</a>
<a href=/tech-blog/blog/ class="nav link"><i class="far fa-newspaper"></i> Blog</a>
<a href=/tech-blog/categories/ class="nav link"><i class="fas fa-sitemap"></i> Categories</a></menu>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav></header><div id=wrapper><section id=site-intro><a href=/tech-blog/><img src=https://yyh-gl.github.io/tech-blog/img/main/logo.webp class=circle width=80 alt="yyh-gl's icon"></a><header><h1>yyh-gl's Tech Blog</h1></header><main><p>技術ネタ中心のブログです。主な扱いはバックエンド技術と設計です。</p></main><footer><ul class=socnet-icons><li><a href=//github.com/yyh-gl target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//twitter.com/yyh_gl target=_blank rel=noopener title=Twitter class="fab fa-twitter"></a></li><li><a href=//speakerdeck.com/yyh_gl target=_blank title="Speaker Deck" class="fab fa-speaker-deck"></a></li><li><a href=//crowdin.com/profile/yyh-gl target=_blank title=Crowdin class="fas fa-pen-square"></a></li></ul></footer></section><main id=site-main><article class=post><header><div class=title><h2><a href=/tech-blog/blog/terraform_ecs/>【Terraform + ECS + RDS】Terraform で ECS環境構築してみた</a></h2></div><div class=meta><time datetime="2019-06-04 00:00:00 +0000 UTC">2019-06-04</time><p>yyh-gl</p><p>9 分で読めます</p></div></header><div id=socnet-share></div><div class=content><a href=/tech-blog/blog/terraform_ecs/ class=image style="--bg-image:url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/terraform_ecs/featured.webp')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/terraform_ecs/featured.webp alt=featured></a><h1 id=terraform-とは>Terraform とは</h1><p>最近流行りの IaC です。</p><p>つまり、コードベースでインフラリソースを管理するためのツールです。</p><p>中でもTerraform はクラウドに特化した IaC ツールという立ち位置です。</p><p>AWSやGCP, Azure などの他に<a href=https://www.terraform.io/docs/providers/index.html target=_blank rel="noopener noreferrer">様々なクラウドプラットフォーム</a>
に対応しています。</p><p>（ちなみに、Vagrant 開発元の <a href=https://www.hashicorp.com/ target=_blank rel="noopener noreferrer">HashiCorp</a>
社が開発しています）</p><h1 id=今回やること>今回やること</h1><p>Terraform で AWS 上に下記のような環境を自動構築します。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/terraform_ecs/architecture.png width=600><br><p>ECS でデプロイされるサービスは ECR から引っ張ってくるようにします。</p><p>そして、そのサービスは Aurora を使うシステムを想定しています。</p><p><u>【⚠注意⚠】上記構成はお金が発生します！ まったくもって無料枠ではありません！</u></p><p>【⚠注意⚠】今回独自ドメインを使用していますが、ドメイン取得に関しては省略しています。</p><h2 id=今回やる内容は>今回やる内容は…</h2><p>僕が所属する会社の研修資料を参考に進めています。</p><p>資料を作成してくださった<a href=https://twitter.com/_y_ohgi target=_blank rel="noopener noreferrer">@_y_ohgi</a>
さんに感謝。</p><h1 id=自動構築プロセス全体で使用する共通設定を定義>自動構築プロセス全体で使用する共通設定を定義</h1><p>まず、 <code>main.tf</code> を作成し、以下のとおり共通設定を定義していきます。</p><pre class=line-numbers><code># AWS を利用することを明示
provider &quot;aws&quot; {
    # リージョンを設定
    region = &quot;ap-northeast-1&quot;
}

# これから作成するリソースに付与する名前のプリフィックスを設定
# グローバル変数的な立ち位置で定義
variable &quot;prefix&quot; {
    default = &quot;sample-project&quot;
}
</code></pre><p><code>provider</code> で使用するクラウドを指定することができます。</p><p><code>variable</code> は変数定義です。</p><p><code>${var.prefix}</code> と書くことで <code>default</code> で指定した内容が展開されます。</p><p>（次の定義ファイルでも変数が出てくるので、そこで使いかたを見てみてください。）</p><p>なお、変数定義を別ファイルに切り出す方法もあるようですが、今回はやりません。</p><p>切り出す方法は<a href=https://qiita.com/ringo/items/3af1735cd833fb80da75#%E5%A4%89%E6%95%B0%E6%88%A6%E7%95%A5%E8%A8%AD%E8%A8%88 target=_blank rel="noopener noreferrer">こちら</a>
が参考になると思います。</p><h1 id=route53-の設定>Route53 の設定</h1><p><code>route53_acm.tf</code> を作成し、以下のとおり定義します。</p><p>内部で ACM に関する定義も行っています。</p><p>以降、クラウドプラットフォームに依存しない設定に関しては【解説】コメントで解説を行っています。</p><p>各 resource の定義内容に関しては コメントにあるURLを参考にしてください。</p><blockquote><p>英語ではありますが、<a href=https://www.terraform.io/docs/providers/aws/index.html target=_blank rel="noopener noreferrer">公式ドキュメント</a>
がとても分かりやすいです</p></blockquote><pre class=line-numbers><code># ドメイン名の設定
variable &quot;domain&quot; {
    description = &quot;「Route53で管理するドメイン」 などの説明文&quot;
    type        = &quot;string&quot;

    # みなさんが持つドメイン名にしてください
    default = &quot;example.com&quot;
}

# Route53 Hosted Zone
# https://www.terraform.io/docs/providers/aws/d/route53_zone.html
# 【解説】data で始まっていますが、これは読み取り専用のリソースであることを示します。
# すでにクラウド上に存在するリソースの値を参照するために使用します。
data &quot;aws_route53_zone&quot; &quot;main&quot; {
    name         = &quot;${var.domain}&quot; # 変数を展開しているところ、ここです
    private_zone = false
}

# ACM
# https://www.terraform.io/docs/providers/aws/r/acm_certificate.html
# 【解説】resource は作成するリソースを定義する場所です。
resource &quot;aws_acm_certificate&quot; &quot;main&quot; {
    domain_name = &quot;${var.domain}&quot;

    validation_method = &quot;DNS&quot;

    lifecycle {
        create_before_destroy = true
    }
}

# Route53 record
# ACMによる検証用レコード
# https://www.terraform.io/docs/providers/aws/r/route53_record.html
resource &quot;aws_route53_record&quot; &quot;validation&quot; {
    depends_on = [&quot;aws_acm_certificate.main&quot;]

    zone_id = &quot;${data.aws_route53_zone.main.id}&quot;

    ttl = 60

    name    = &quot;${aws_acm_certificate.main.domain_validation_options.0.resource_record_name}&quot;
    type    = &quot;${aws_acm_certificate.main.domain_validation_options.0.resource_record_type}&quot;
    records = [&quot;${aws_acm_certificate.main.domain_validation_options.0.resource_record_value}&quot;]
}

# ACM Validate
# https://www.terraform.io/docs/providers/aws/r/acm_certificate_validation.html
resource &quot;aws_acm_certificate_validation&quot; &quot;main&quot; {
    certificate_arn = &quot;${aws_acm_certificate.main.arn}&quot;

    validation_record_fqdns = [&quot;${aws_route53_record.validation.0.fqdn}&quot;]
}

# Route53 record
# https://www.terraform.io/docs/providers/aws/r/route53_record.html
resource &quot;aws_route53_record&quot; &quot;main&quot; {
    type = &quot;A&quot;

    name    = &quot;${var.domain}&quot;
    zone_id = &quot;${data.aws_route53_zone.main.id}&quot;

    alias = {
        name                   = &quot;${aws_lb.main.dns_name}&quot;
        zone_id                = &quot;${aws_lb.main.zone_id}&quot;
        evaluate_target_health = true
    }
}

# ALB Listener
# https://www.terraform.io/docs/providers/aws/r/lb_listener.html
resource &quot;aws_lb_listener&quot; &quot;https&quot; {
    load_balancer_arn = &quot;${aws_lb.main.arn}&quot;

    certificate_arn = &quot;${aws_acm_certificate.main.arn}&quot;

    port     = &quot;443&quot;
    protocol = &quot;HTTPS&quot;

    default_action {
        type             = &quot;forward&quot;
        target_group_arn = &quot;${aws_lb_target_group.main.id}&quot;
    }
}

# ALB Listener Rule
# https://www.terraform.io/docs/providers/aws/r/lb_listener_rule.html
resource &quot;aws_lb_listener_rule&quot; &quot;http_to_https&quot; {
    listener_arn = &quot;${aws_lb_listener.main.arn}&quot;

    priority = 99

    action {
        type = &quot;redirect&quot;

        redirect {
            port        = &quot;443&quot;
            protocol    = &quot;HTTPS&quot;
            status_code = &quot;HTTP_301&quot;
        }
    }

    condition {
        field  = &quot;host-header&quot;
        values = [&quot;${var.domain}&quot;]
    }
}

# Security Group Rule
# https://www.terraform.io/docs/providers/aws/r/security_group_rule.html
resource &quot;aws_security_group_rule&quot; &quot;alb_https&quot; {
    security_group_id = &quot;${aws_security_group.alb.id}&quot;

    type = &quot;ingress&quot;

    from_port = 443
    to_port   = 443
    protocol  = &quot;tcp&quot;

    cidr_blocks = [&quot;0.0.0.0/0&quot;]
}
</code></pre><h1 id=vpcの設定>VPCの設定</h1><p><code>vpc.tf</code> を以下のとおり定義します。</p><p>ここで、 <code>main.tf</code> で定義した変数が大活躍します。</p><pre class=line-numbers><code># VPC
# https://www.terraform.io/docs/providers/aws/r/vpc.html
resource &quot;aws_vpc&quot; &quot;main&quot; {
	cidr_block = &quot;10.0.0.0/16&quot;

	tags = {
		Name = &quot;${var.prefix}-vpc&quot;
	}
}

# Public Subnet
# https://www.terraform.io/docs/providers/aws/r/subnet.html
resource &quot;aws_subnet&quot; &quot;public_1a&quot; {
	# 先程作成したVPCを参照し、そのVPC内にSubnetを立てる
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	# Subnetを作成するAZ
	availability_zone = &quot;ap-northeast-1a&quot;

	cidr_block = &quot;10.0.1.0/24&quot;

	tags = {
		Name = &quot;${var.prefix}-public-1a&quot;
	}
}

resource &quot;aws_subnet&quot; &quot;public_1c&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	availability_zone = &quot;ap-northeast-1c&quot;

	cidr_block = &quot;10.0.2.0/24&quot;

	tags = {
		Name = &quot;${var.prefix}-public-1c&quot;
	}
}

resource &quot;aws_subnet&quot; &quot;public_1d&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	availability_zone = &quot;ap-northeast-1d&quot;

	cidr_block = &quot;10.0.3.0/24&quot;

	tags = {
		Name = &quot;${var.prefix}-public-1d&quot;
	}
}

# Private Subnets
resource &quot;aws_subnet&quot; &quot;private_1a&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	availability_zone = &quot;ap-northeast-1a&quot;

	cidr_block = &quot;10.0.10.0/24&quot;

	tags = {
		Name = &quot;${var.prefix}-private-1a&quot;
	}
}

resource &quot;aws_subnet&quot; &quot;private_1c&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	availability_zone = &quot;ap-northeast-1c&quot;

	cidr_block = &quot;10.0.20.0/24&quot;

	tags = {
		Name = &quot;${var.prefix}-private-1c&quot;
	}
}

resource &quot;aws_subnet&quot; &quot;private_1d&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	availability_zone = &quot;ap-northeast-1d&quot;

	cidr_block = &quot;10.0.30.0/24&quot;

	tags = {
		Name = &quot;${var.prefix}-private-1d&quot;
	}
}

# Internet Gateway
# https://www.terraform.io/docs/providers/aws/r/internet_gateway.html
resource &quot;aws_internet_gateway&quot; &quot;main&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	tags = {
		Name = &quot;${var.prefix}-igw&quot;
	}
}

# Elasti IP
# NAT Gateway には1つの Elastic IP が必要なので作成
# https://www.terraform.io/docs/providers/aws/r/eip.html
resource &quot;aws_eip&quot; &quot;nat_1a&quot; {
	vpc = true

	tags = {
		Name = &quot;${var.prefix}-eip-for-natgw-1a&quot;
	}
}

# NAT Gateway
# https://www.terraform.io/docs/providers/aws/r/nat_gateway.html
resource &quot;aws_nat_gateway&quot; &quot;nat_1a&quot; {
	subnet_id     = &quot;${aws_subnet.public_1a.id}&quot; # NAT Gatewayを配置するSubnetを指定
	allocation_id = &quot;${aws_eip.nat_1a.id}&quot;       # 紐付けるElasti IP

	tags = {
		Name = &quot;${var.prefix}-natgw-1a&quot;
	}
}

resource &quot;aws_eip&quot; &quot;nat_1c&quot; {
	vpc = true

	tags = {
		Name = &quot;${var.prefix}-eip-for-natgw-1c&quot;
	}
}

resource &quot;aws_nat_gateway&quot; &quot;nat_1c&quot; {
	subnet_id     = &quot;${aws_subnet.public_1c.id}&quot;
	allocation_id = &quot;${aws_eip.nat_1c.id}&quot;

	tags = {
		Name = &quot;${var.prefix}-natgw-1c&quot;
	}
}

resource &quot;aws_eip&quot; &quot;nat_1d&quot; {
	vpc = true

	tags = {
		Name = &quot;${var.prefix}-eip-for-natgw-1d&quot;
	}
}

resource &quot;aws_nat_gateway&quot; &quot;nat_1d&quot; {
	subnet_id     = &quot;${aws_subnet.public_1d.id}&quot;
	allocation_id = &quot;${aws_eip.nat_1d.id}&quot;

	tags = {
		Name = &quot;${var.prefix}-natgw-1d&quot;
	}
}

# Route Table
# https://www.terraform.io/docs/providers/aws/r/route_table.html
resource &quot;aws_route_table&quot; &quot;public&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	tags = {
		Name = &quot;${var.prefix}-public-route-table&quot;
	}
}

# Route
# https://www.terraform.io/docs/providers/aws/r/route.html
resource &quot;aws_route&quot; &quot;public&quot; {
	destination_cidr_block = &quot;0.0.0.0/0&quot;
	route_table_id         = &quot;${aws_route_table.public.id}&quot;
	gateway_id             = &quot;${aws_internet_gateway.main.id}&quot;
}

# Association
# https://www.terraform.io/docs/providers/aws/r/route_table_association.html
resource &quot;aws_route_table_association&quot; &quot;public_1a&quot; {
	subnet_id      = &quot;${aws_subnet.public_1a.id}&quot;
	route_table_id = &quot;${aws_route_table.public.id}&quot;
}

resource &quot;aws_route_table_association&quot; &quot;public_1c&quot; {
	subnet_id      = &quot;${aws_subnet.public_1c.id}&quot;
	route_table_id = &quot;${aws_route_table.public.id}&quot;
}

resource &quot;aws_route_table_association&quot; &quot;public_1d&quot; {
	subnet_id      = &quot;${aws_subnet.public_1d.id}&quot;
	route_table_id = &quot;${aws_route_table.public.id}&quot;
}

# Route Table (Private)
# https://www.terraform.io/docs/providers/aws/r/route_table.html
resource &quot;aws_route_table&quot; &quot;private_1a&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	tags = {
		Name = &quot;${var.prefix}--private-1a&quot;
	}
}

resource &quot;aws_route_table&quot; &quot;private_1c&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	tags = {
		Name = &quot;${var.prefix}--private-1c&quot;
	}
}

resource &quot;aws_route_table&quot; &quot;private_1d&quot; {
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	tags = {
		Name = &quot;${var.prefix}--private-1d&quot;
	}
}

# Route (Private)
# https://www.terraform.io/docs/providers/aws/r/route.html
resource &quot;aws_route&quot; &quot;private_1a&quot; {
	destination_cidr_block = &quot;0.0.0.0/0&quot;
	route_table_id         = &quot;${aws_route_table.private_1a.id}&quot;
	nat_gateway_id         = &quot;${aws_nat_gateway.nat_1a.id}&quot;
}

resource &quot;aws_route&quot; &quot;private_1c&quot; {
	destination_cidr_block = &quot;0.0.0.0/0&quot;
	route_table_id         = &quot;${aws_route_table.private_1c.id}&quot;
	nat_gateway_id         = &quot;${aws_nat_gateway.nat_1c.id}&quot;
}

resource &quot;aws_route&quot; &quot;private_1d&quot; {
	destination_cidr_block = &quot;0.0.0.0/0&quot;
	route_table_id         = &quot;${aws_route_table.private_1d.id}&quot;
	nat_gateway_id         = &quot;${aws_nat_gateway.nat_1d.id}&quot;
}

# Association (Private)
# https://www.terraform.io/docs/providers/aws/r/route_table_association.html
resource &quot;aws_route_table_association&quot; &quot;private_1a&quot; {
	subnet_id      = &quot;${aws_subnet.private_1a.id}&quot;
	route_table_id = &quot;${aws_route_table.private_1a.id}&quot;
}

resource &quot;aws_route_table_association&quot; &quot;private_1c&quot; {
	subnet_id      = &quot;${aws_subnet.private_1c.id}&quot;
	route_table_id = &quot;${aws_route_table.private_1c.id}&quot;
}

resource &quot;aws_route_table_association&quot; &quot;private_1d&quot; {
	subnet_id      = &quot;${aws_subnet.private_1d.id}&quot;
	route_table_id = &quot;${aws_route_table.private_1d.id}&quot;
}
</code></pre><h1 id=ロードバランサの設定>ロードバランサの設定</h1><p>次は ALB の定義を作成します。</p><p><code>alb.tf</code> に以下のとおり定義します。</p><pre class=line-numbers><code># SecurityGroup
# https://www.terraform.io/docs/providers/aws/r/security_group.html
resource &quot;aws_security_group&quot; &quot;alb&quot; {
    name        = &quot;${var.prefix}-alb&quot;
    description = &quot;${var.prefix} alb&quot;
    vpc_id      = &quot;${aws_vpc.main.id}&quot;

    # セキュリティグループ内のリソースからインターネットへのアクセスを許可する
    egress {
        from_port   = 0
        to_port     = 0
        protocol    = &quot;-1&quot;
        cidr_blocks = [&quot;0.0.0.0/0&quot;]
    }

    tags = {
        Name = &quot;${var.prefix}-alb&quot;
    }
}

# SecurityGroup Rule
# https://www.terraform.io/docs/providers/aws/r/security_group.html
resource &quot;aws_security_group_rule&quot; &quot;alb_http&quot; {
    security_group_id = &quot;${aws_security_group.alb.id}&quot;

    # セキュリティグループ内のリソースへインターネットからのアクセスを許可する
    type = &quot;ingress&quot;

    from_port = 80
    to_port   = 80
    protocol  = &quot;tcp&quot;

    cidr_blocks = [&quot;0.0.0.0/0&quot;]
}

# ALB
# https://www.terraform.io/docs/providers/aws/d/lb.html
resource &quot;aws_lb&quot; &quot;main&quot; {
    load_balancer_type = &quot;application&quot;
    name               = &quot;${var.prefix}&quot;

    security_groups = [&quot;${aws_security_group.alb.id}&quot;]
    subnets         = [&quot;${aws_subnet.public_1a.id}&quot;, &quot;${aws_subnet.public_1c.id}&quot;, &quot;${aws_subnet.public_1d.id}&quot;]
}

# Listener
# https://www.terraform.io/docs/providers/aws/r/lb_listener.html
resource &quot;aws_lb_listener&quot; &quot;main&quot; {
    # HTTPでのアクセスを受け付ける
    port              = &quot;80&quot;
    protocol          = &quot;HTTP&quot;

    # ALBのarnを指定します。
    load_balancer_arn = &quot;${aws_lb.main.arn}&quot;

    # &quot;ok&quot; という固定レスポンスを設定する
    default_action {
        type             = &quot;fixed-response&quot;

        fixed_response {
            content_type = &quot;text/plain&quot;
            status_code  = &quot;200&quot;
            message_body = &quot;ok&quot;
        }
    }
}
</code></pre><h1 id=ecsの設定>ECSの設定</h1><p><code>ecs.tf</code> はこんな感じです。</p><pre class=line-numbers><code>resource &quot;aws_iam_role&quot; &quot;ecs_task_execution_role&quot; {
	name = &quot;ecs_task_execution_role&quot;
	assume_role_policy = &lt;&lt;EOF
{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Sid&quot;: &quot;&quot;,
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Principal&quot;: {
        &quot;Service&quot;: [
          &quot;ecs-tasks.amazonaws.com&quot;
        ]
      },
      &quot;Action&quot;: &quot;sts:AssumeRole&quot;
    }
  ]
}
EOF
}

resource &quot;aws_iam_role_policy_attachment&quot; &quot;ecs-task-execution-policy&quot; {
	role = &quot;${aws_iam_role.ecs_task_execution_role.name}&quot;
	policy_arn = &quot;arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy&quot;
}

resource &quot;aws_iam_role_policy_attachment&quot; &quot;ecr-read-policy&quot; {
	role = &quot;${aws_iam_role.ecs_task_execution_role.name}&quot;
	policy_arn = &quot;arn:aws:iam::aws:policy/AmazonSSMReadOnlyAccess&quot;
}

# Task Definition
# https://www.terraform.io/docs/providers/aws/r/ecs_task_definition.html
resource &quot;aws_ecs_task_definition&quot; &quot;main&quot; {
	family = &quot;${var.prefix}&quot;

	# データプレーンの選択
	requires_compatibilities = [&quot;FARGATE&quot;]

	# ECSタスクが使用可能なリソースの上限
	# タスク内のコンテナはこの上限内に使用するリソースを収める必要があり
	# メモリが上限に達した場合OOM Killer にタスクがキルされる
	cpu    = &quot;256&quot;
	memory = &quot;512&quot;

	# ECSタスクのネットワークドライバ
	# Fargateを使用する場合は&quot;awsvpc&quot;決め打ち
	network_mode = &quot;awsvpc&quot;

	# ECRからDocker ImageをPULLするための権限
	execution_role_arn = &quot;${aws_iam_role.ecs_task_execution_role.arn}&quot;

	# 起動するコンテナの定義
	# 【解説1】JSONでコンテナを定義します
	# 【解説2】JSON内の environment で環境変数を設定します。
	# environment ではデータベースのホストを設定しています。
	# 機密情報（次の項目で設定します）として登録するか迷いましたが、
	# 機密情報だとパラメータストアを経由する必要があり、
	# 手動設定が必要になるので、環境変数にしました。
	# プライベートサブネットに入ってるので大丈夫だと考えています。
	# 【解説3】JSON内の secrets で機密情報を設定します。
	# 今回はよく使いそうなものを適当に定義しました。
	# 機密情報 は System Manager のパラメータストアから持ってきます。
	container_definitions = &lt;&lt;EOL
[
  {
    &quot;name&quot;: &quot;&lt;your repository name&gt;&quot;,
    &quot;image&quot;: &quot;&lt;your image name&gt;&quot;,
    &quot;portMappings&quot;: [
      {
        &quot;containerPort&quot;: 8080,
        &quot;hostPort&quot;: 8080
      }
    ],
    &quot;environment&quot;: [
        {
            &quot;name&quot;: &quot;MYSQL_HOST&quot;,
            &quot;value&quot;: &quot;${aws_rds_cluster.this.endpoint}&quot;
        }
    ],
    &quot;secrets&quot;: [
      {
        &quot;name&quot;: &quot;MYSQL_PASSWORD&quot;,
        &quot;valueFrom&quot;: &quot;arn:aws:ssm:ap-northeast-1:910114278227:parameter/MYSQL_PASSWORD&quot;
      },
      {
        &quot;name&quot;: &quot;MYSQL_USER&quot;,
        &quot;valueFrom&quot;: &quot;arn:aws:ssm:ap-northeast-1:910114278227:parameter/MYSQL_USER&quot;
      },
      {
        &quot;name&quot;: &quot;MYSQL_DATABASE&quot;,
        &quot;valueFrom&quot;: &quot;arn:aws:ssm:ap-northeast-1:910114278227:parameter/MYSQL_DATABASE&quot;
      },
      {
        &quot;name&quot;: &quot;AWS_ACCESS_KEY&quot;,
        &quot;valueFrom&quot;: &quot;arn:aws:ssm:ap-northeast-1:910114278227:parameter/ACCESS_KEY&quot;
      },
      {
        &quot;name&quot;: &quot;AWS_SECRET_KEY&quot;,
        &quot;valueFrom&quot;: &quot;arn:aws:ssm:ap-northeast-1:910114278227:parameter/SECRET_KEY&quot;
      },
      {
        &quot;name&quot;: &quot;S3_BUCKET_NAME&quot;,
        &quot;valueFrom&quot;: &quot;arn:aws:ssm:ap-northeast-1:910114278227:parameter/S3_BUCKET_NAME&quot;
      },
      {
        &quot;name&quot;: &quot;AUTH_SECRET&quot;,
        &quot;valueFrom&quot;: &quot;arn:aws:ssm:ap-northeast-1:910114278227:parameter/AUTH_SECRET&quot;
      }
    ]
  }
]
EOL
}

# ECS Cluster
# https://www.terraform.io/docs/providers/aws/r/ecs_cluster.html
resource &quot;aws_ecs_cluster&quot; &quot;main&quot; {
	name = &quot;${var.prefix}&quot;
}

# ELB Target Group
# https://www.terraform.io/docs/providers/aws/r/lb_target_group.html
resource &quot;aws_lb_target_group&quot; &quot;main&quot; {
	name = &quot;${var.prefix}&quot;

	# ターゲットグループを作成するVPC
	vpc_id = &quot;${aws_vpc.main.id}&quot;

	# ALBからECSタスクのコンテナへトラフィックを振り分ける設定
	port        = 8080
	protocol    = &quot;HTTP&quot;
	target_type = &quot;ip&quot;

	# コンテナへの死活監視設定
	health_check = {
		port = 8080
		path = &quot;/health&quot;
	}
}

# ALB Listener Rule
# https://www.terraform.io/docs/providers/aws/r/lb_listener_rule.html
resource &quot;aws_lb_listener_rule&quot; &quot;main&quot; {
	# ルールを追加するリスナー
	listener_arn = &quot;${aws_lb_listener.main.arn}&quot;

	# 受け取ったトラフィックをターゲットグループへ受け渡す
	action {
		type             = &quot;forward&quot;
		target_group_arn = &quot;${aws_lb_target_group.main.id}&quot;
	}

	# ターゲットグループへ受け渡すトラフィックの条件
	condition {
		field  = &quot;path-pattern&quot;
		values = [&quot;*&quot;]
	}
}

# SecurityGroup
# https://www.terraform.io/docs/providers/aws/r/security_group.html
resource &quot;aws_security_group&quot; &quot;ecs&quot; {
	name        = &quot;${var.prefix}-ecs&quot;
	description = &quot;${var.prefix} ecs&quot;

	# セキュリティグループを配置するVPC
	vpc_id      = &quot;${aws_vpc.main.id}&quot;

	# セキュリティグループ内のリソースからインターネットへのアクセス許可設定
	# 今回の場合DockerHubへのPullに使用する。
	egress {
		from_port   = 0
		to_port     = 0
		protocol    = &quot;-1&quot;
		cidr_blocks = [&quot;0.0.0.0/0&quot;]
	}

	tags = {
		Name = &quot;${var.prefix}-ecs&quot;
	}
}

# SecurityGroup Rule
# https://www.terraform.io/docs/providers/aws/r/security_group.html
resource &quot;aws_security_group_rule&quot; &quot;ecs&quot; {
	security_group_id = &quot;${aws_security_group.ecs.id}&quot;

	# インターネットからセキュリティグループ内のリソースへのアクセス許可設定
	type = &quot;ingress&quot;

	# TCPでの80ポートへのアクセスを許可する
	from_port = 80
	to_port   = 8080
	protocol  = &quot;tcp&quot;

	# 同一VPC内からのアクセスのみ許可
	cidr_blocks = [&quot;10.0.0.0/16&quot;]
}

# ECS Service
# https://www.terraform.io/docs/providers/aws/r/ecs_service.html
resource &quot;aws_ecs_service&quot; &quot;main&quot; {
	name = &quot;${var.prefix}&quot;

	# 依存関係の記述。
	# &quot;aws_lb_listener_rule.main&quot; リソースの作成が完了するのを待ってから当該リソースの作成を開始する。
	# &quot;depends_on&quot; は &quot;aws_ecs_service&quot; リソース専用のプロパティではなく、Terraformのシンタックスのため他の&quot;resource&quot;でも使用可能
	depends_on = [&quot;aws_lb_listener_rule.main&quot;]

	# 当該ECSサービスを配置するECSクラスターの指定
	cluster = &quot;${aws_ecs_cluster.main.name}&quot;

	# データプレーンとしてFargateを使用する
	launch_type = &quot;FARGATE&quot;

	# ECSタスクの起動数を定義
	desired_count = &quot;1&quot;

	# 起動するECSタスクのタスク定義
	task_definition = &quot;${aws_ecs_task_definition.main.arn}&quot;

	# ECSタスクへ設定するネットワークの設定
	network_configuration = {
		# タスクの起動を許可するサブネット
		subnets         = [&quot;${aws_subnet.private_1a.id}&quot;, &quot;${aws_subnet.private_1c.id}&quot;, &quot;${aws_subnet.private_1d.id}&quot;]
		# タスクに紐付けるセキュリティグループ
		security_groups = [&quot;${aws_security_group.ecs.id}&quot;]
	}

	# ECSタスクの起動後に紐付けるELBターゲットグループ
	load_balancer = [
		{
			target_group_arn = &quot;${aws_lb_target_group.main.arn}&quot;
			container_name   = &quot;&lt;your container name&gt;&quot;
			container_port   = &quot;8080&quot;
		},
	]
}
</code></pre><p>機密情報を渡すところに関しては <a href=https://khigashigashi.hatenablog.com/entry/2018/08/28/214417 target=_blank rel="noopener noreferrer">こちら</a>
の記事が分かりやすいです。</p><p>機密情報として設定する値は System Manager のパラメータストアにセットする必要があります。</p><h1 id=rdsの設定>RDSの設定</h1><p>最後に <code>rds.tf</code> を以下のとおり定義します。</p><pre class=line-numbers><code># SSM Parameter data source
# https://www.terraform.io/docs/providers/aws/d/ssm_parameter.html
data &quot;aws_ssm_parameter&quot; &quot;database_name&quot; {
	name = &quot;MYSQL_DATABASE&quot;
}

data &quot;aws_ssm_parameter&quot; &quot;database_user&quot; {
	name = &quot;MYSQL_USER&quot;
}

data &quot;aws_ssm_parameter&quot; &quot;database_password&quot; {
	name = &quot;MYSQL_PASSWORD&quot;
}

# 【解説】locals は名前のとおりローカル変数です。
# variables だと `${}` 展開できないのでこちらを使用しました。
# 他にやり方があれば教えてほしいです。
locals {
	name = &quot;${var.prefix}-rds-mysql&quot;
}

resource &quot;aws_security_group&quot; &quot;this&quot; {
	name        = &quot;${local.name}&quot;
	description = &quot;${local.name}&quot;

	vpc_id = &quot;${aws_vpc.main.id}&quot;

  egress {
	  from_port   = 0
	  to_port     = 0
	  protocol    = &quot;-1&quot;
	  cidr_blocks = [&quot;0.0.0.0/0&quot;]
  }

  tags = {
	  Name = &quot;${local.name}&quot;
  }
}

resource &quot;aws_security_group_rule&quot; &quot;mysql&quot; {
	security_group_id = &quot;${aws_security_group.this.id}&quot;

	type = &quot;ingress&quot;

	from_port   = 3306
	to_port     = 3306
	protocol    = &quot;tcp&quot;
	cidr_blocks = [&quot;10.0.0.0/16&quot;]
}

resource &quot;aws_db_subnet_group&quot; &quot;this&quot; {
	name        = &quot;${local.name}&quot;
	description = &quot;${local.name}&quot;
	subnet_ids  = [
		&quot;${aws_subnet.private_1a.id}&quot;,
		&quot;${aws_subnet.private_1c.id}&quot;,
		&quot;${aws_subnet.private_1d.id}&quot;,
	]
}

# RDS Cluster
# https://www.terraform.io/docs/providers/aws/r/rds_cluster.html
resource &quot;aws_rds_cluster&quot; &quot;this&quot; {
	cluster_identifier = &quot;${local.name}&quot;

	db_subnet_group_name   = &quot;${aws_db_subnet_group.this.name}&quot;
	vpc_security_group_ids = [&quot;${aws_security_group.this.id}&quot;]

	engine = &quot;aurora-mysql&quot;
	port   = &quot;3306&quot;

	database_name   = &quot;${data.aws_ssm_parameter.database_name.value}&quot;
	master_username = &quot;${data.aws_ssm_parameter.database_user.value}&quot;
	master_password = &quot;${data.aws_ssm_parameter.database_password.value}&quot;

	# RDSインスタンス削除時のスナップショットの取得強制を無効化
	skip_final_snapshot = true

	# 使用する Parameter Group を指定
	db_cluster_parameter_group_name = &quot;${aws_rds_cluster_parameter_group.this.name}&quot;
}

# RDS Cluster Instance
# https://www.terraform.io/docs/providers/aws/r/rds_cluster_instance.html
resource &quot;aws_rds_cluster_instance&quot; &quot;this&quot; {
	identifier         = &quot;${local.name}&quot;
	cluster_identifier = &quot;${aws_rds_cluster.this.id}&quot;

	engine = &quot;aurora-mysql&quot;

	instance_class = &quot;db.t3.small&quot;
}

# RDS Cluster Parameter Group
# https://www.terraform.io/docs/providers/aws/r/rds_cluster_parameter_group.html
# 日本時間に変更 &amp; 日本語対応のために文字コードを変更
resource &quot;aws_rds_cluster_parameter_group&quot; &quot;this&quot; {
	name   = &quot;${local.name}&quot;
	family = &quot;aurora-mysql5.7&quot;

	parameter {
		name  = &quot;time_zone&quot;
		value = &quot;Asia/Tokyo&quot;
	}

	parameter {
		name  = &quot;character_set_client&quot;
		value = &quot;utf8mb4&quot;
	}

	parameter {
		name  = &quot;character_set_connection&quot;
		value = &quot;utf8mb4&quot;
	}

	parameter {
		name  = &quot;character_set_database&quot;
		value = &quot;utf8mb4&quot;
	}

	parameter {
		name  = &quot;character_set_results&quot;
		value = &quot;utf8mb4&quot;
	}

	parameter {
		name  = &quot;character_set_server&quot;
		value = &quot;utf8mb4&quot;
	}
}

# terraform applyコマンド完了時にコンソールにエンドポイントを表示
# 【解説】もしエンドポイントも機密情報として扱うのであれば
# ここで表示されたエンドポイントをパラメータストアに格納すればよい。
# 今回は紹介のために使用。
output &quot;rds_endpoint&quot; {
	value = &quot;${aws_rds_cluster.this.endpoint}&quot;
}
</code></pre><h1 id=テスト>テスト</h1><p>上記で作成してきた tfファイルたちを同じディレクトリに格納し、</p><p>そのディレクトリ内で下記コマンドを実行します。</p><p><code>AWS_ACCESS_KEY_ID=&lt;your access key> AWS_SECRET_ACCESS_KEY=&lt;your secret access key> terraform apply</code></p><p>アクセスキーとシークレットキーは IAM から取得してください。</p><p>terraform コマンドが入ってない人は brew やらなんやらでインストールお願いします。</p><br><p>実行して（かなり時間がかかりますが）下記のように出力されたら成功です！</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/terraform_ecs/terraform_apply_success.png width=600><br><p>削除もやってみましょう。</p><p><code>AWS_ACCESS_KEY_ID=&lt;your access key> AWS_SECRET_ACCESS_KEY=&lt;your secret access key> terraform destroy</code></p><p>こちらもかなり時間がかかりますが、下記のようにリソースが削除されると思います。</p><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/06/terraform_ecs/terraform_destroy_success.png width=600><h2 id=tfファイルの実行順>tfファイルの実行順</h2><p>tfファイル内で作成したリソースから取得した値を他のリソースで使用する場面がありました。</p><p>ここで気になるのが tfファイルの実行順番です。</p><p>実行順番次第では、取得したい値がまだできていないということも起こりそうです。</p><p>これに関して、結論から言うと僕たちが順番を考える必要はありません。</p><p>tfファイルを適当にディレクトリに突っ込んだだけですが、</p><p>terraform 側でよしなに順番を決めてやってくれます。</p><p>すごい。</p><h1 id=まとめ>まとめ</h1><p>Terraformすごい。</p><p>自動でここまでできてしまう。</p><p>しかも、コードで定義するからバージョン管理できる。</p><p>差分チェックできる。</p><p>「分かる、こいつ強い。」</p><br><p>今回はファイル分割しただけですが、モジュール分割とかもできるようなので今後やっていきます。</p></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/tech-blog/categories/aws/>AWS</a></li><li><a class=article-terms-link href=/tech-blog/categories/terraform/>Terraform</a></li><li><a class=article-terms-link href=/tech-blog/categories/ecs/>ECS</a></li><li><a class=article-terms-link href=/tech-blog/categories/rds/>RDS</a></li></ul><div><good-counter rel-permalink=/tech-blog/blog/terraform_ecs/></good-counter></div></div></footer><div class=fix><a href="https://github.com/yyh-gl/tech-blog/issues/new?template=fix_proposal.md&assignees=yyh-gl&title=修正提案：『%e3%80%90Terraform%20%2b%20ECS%20%2b%20RDS%e3%80%91Terraform%20%e3%81%a7%20ECS%e7%92%b0%e5%a2%83%e6%a7%8b%e7%af%89%e3%81%97%e3%81%a6%e3%81%bf%e3%81%9f』" target=_blank rel="noopener noreferrer">修正提案</a></div></article><div class=pagination><a href=/tech-blog/blog/scrum_entry/ class="button left"><span>スクラムについて学んだ話</span></a>
<a href=/tech-blog/blog/android_push/ class="button right"><span>【Android + Kotlin + Firebase】Androidアプリにプッシュ通知を実装してみた</span></a></div></main><section id=site-sidebar><section id=recent-posts><header><h1>最近の投稿</h1></header><article class=mini-post><a href=/tech-blog/blog/activity-2021/ class=image style="--bg-image:url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2022/01/activity-2021/featured.webp')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2022/01/activity-2021/featured.webp alt=featured></a><header><h2><a href=/tech-blog/blog/activity-2021/>【2021年】アクティビティまとめ</a></h2><time class=published datetime="2022-01-02 11:59:04 +0000 UTC">2022-01-02</time></header></article><article class=mini-post><a href=/tech-blog/blog/go-build/ class=image style="--bg-image:url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2021/12/go-build/featured.webp')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2021/12/go-build/featured.webp alt=featured></a><header><h2><a href=/tech-blog/blog/go-build/>徒然なるままに go build と build tag を見ていく</a></h2><time class=published datetime="2021-12-19 00:00:00 +0000 UTC">2021-12-19</time></header></article><article class=mini-post><a href=/tech-blog/blog/activity-2020/ class=image style="--bg-image:url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2021/02/activity-2020/featured.webp')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2021/02/activity-2020/featured.webp alt=featured></a><header><h2><a href=/tech-blog/blog/activity-2020/>【2020年】アクティビティまとめ</a></h2><time class=published datetime="2021-02-23 09:41:54 +0000 UTC">2021-02-23</time></header></article><footer><a href=/tech-blog/blog/ class=button>続きを見る</a></footer></section><section id=mini-bio><header><h1>About</h1></header><p>東京で働くソフトウェアエンジニアです。バックエンドがメインですが、フロントやインフラもさわっています。</p><footer><a href=/tech-blog/about class=button>もっと詳しく知る</a></footer></section></section><footer id=site-footer><ul class=socnet-icons><li><a href=//github.com/yyh-gl target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//twitter.com/yyh_gl target=_blank rel=noopener title=Twitter class="fab fa-twitter"></a></li><li><a href=//speakerdeck.com/yyh_gl target=_blank title="Speaker Deck" class="fab fa-speaker-deck"></a></li><li><a href=//crowdin.com/profile/yyh-gl target=_blank title=Crowdin class="fas fa-pen-square"></a></li></ul><p class=copyright>© 2022 yyh-gl's Tech Blog<br>Theme: <a href=https://github.com/pacollins/hugo-future-imperfect-slim target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>A <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP port</a> | Powered by <a href=https://gohugo.io/ title=0.94.2 target=_blank rel=noopener>Hugo</a></p></footer><a id=back-to-top href=# class="fas fa-arrow-up fa-2x"></a>
<script src=/tech-blog/js/bundle.min.a1954149b9950c3cc64476f31a0f4adb6e38b0f1db5b587655d1e9aaf1b8a1dc.js integrity="sha256-oZVBSbmVDDzGRHbzGg9K2244sPHbW1h2VdHpqvG4odw="></script>
<script src=/tech-blog/js/add-on.js></script>
<script src=/tech-blog/js/prism.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-140914324-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></body></html>