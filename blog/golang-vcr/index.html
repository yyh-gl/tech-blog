<!doctype html><html lang=ja><head><meta charset=utf-8><title>【Golang+VCR】外部APIとの通信を保存してテストに使用する話 - yyh-gl's Tech Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=apple-touch-icon sizes=180x180 href="/tech-blog/favicon/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/tech-blog/favicon/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/tech-blog/favicon/favicon-16x16.png?v=1"><link rel=manifest href="/tech-blog/favicon/site.webmanifest?v=1"><link rel=mask-icon href="/tech-blog/favicon/safari-pinned-tab.svg?v=1" color=#ffffff><link rel="shortcut icon" href="/tech-blog/favicon/favicon.ico?v=1"><meta name=msapplication-config content="/tech-blog/favicon/browserconfig.xml?v=1"><meta name=msapplication-TileColor content="#ffffff"><meta name=theme-color content="#ffffff"><meta name=generator content="Hugo 0.78.1"><meta property="og:site_name" content="yyh-gl's Tech Blog"><meta property="og:title" content="【Golang+VCR】外部APIとの通信を保存してテストに使用する話"><meta property="og:description" content="Go3 Advent Calendar 2019 8日目"><meta property="description" content="Go3 Advent Calendar 2019 8日目"><meta property="og:url" content="https://yyh-gl.github.io/tech-blog/blog/golang-vcr/"><meta property="og:type" content="article"><meta property="og:image" content="https://yyh-gl.github.io/tech-blog/img/main/logo.png"><link rel=stylesheet href=/tech-blog/css/bundle.min.06087fe1297eeec498927bc319968af3e53cf1a3f852435eb29c65d2d978a17a.css integrity="sha256-Bgh/4Sl+7sSYknvDGZaK8+U88aP4UkNespxl0tl4oXo="><link rel=stylesheet href=/tech-blog/css/add-on.css><link rel=stylesheet href=/tech-blog/css/prism.css><script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js></script><script src=/tech-blog/js/vue.min.js></script><script src=/tech-blog/js/good-counter.js defer></script></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/tech-blog/ class=nav>Blog</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=/tech-blog/ class="nav link"><i class="fa fa-home"></i>Home</a>
<a href=/tech-blog/about/ class="nav link"><i class="far fa-id-card"></i>About</a>
<a href=/tech-blog/blog/ class="nav link"><i class="far fa-newspaper"></i>Blog</a>
<a href=/tech-blog/categories/ class="nav link"><i class="fas fa-sitemap"></i>Categories</a></menu>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav></header><div id=wrapper><section id=site-intro><a href=/tech-blog/><img src=https://yyh-gl.github.io/tech-blog/img/main/logo.png class=circle width=80 alt="yyh-gl's icon"></a><header><h1>yyh-gl's Tech Blog</h1></header><main><p>技術ネタ中心のブログです。主な扱いはバックエンド技術と設計です。</p></main><footer><ul class=socnet-icons><li><a href=//github.com/yyh-gl target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//twitter.com/yyh_gl target=_blank rel=noopener title=Twitter class="fab fa-twitter"></a></li></ul></footer></section><main id=site-main><article class=post><header><div class=title><h2><a href=/tech-blog/blog/golang-vcr/>【Golang+VCR】外部APIとの通信を保存してテストに使用する話</a></h2><p>Go3 Advent Calendar 2019 8日目</p></div><div class=meta><time datetime="2019-12-08 00:00:00 +0000 UTC">2019-12-08</time><p>yyh-gl</p><p>5 分で読めます</p></div></header><div id=socnet-share></div><div class=content><a href=/tech-blog/blog/golang-vcr/ class=image style="--bg-image: url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/12/golang-vcr/featured.png')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2019/12/golang-vcr/featured.png alt=画像がどこかへ逝ってしまったようだ…></a><hr><h1 id=go3-advent-calendar-2019>Go3 Advent Calendar 2019</h1><hr><p>本記事は <a href=https://qiita.com/advent-calendar/2019/go3>Go3 Advent Calendar 2019</a> の 8日目 の記事です。</p><p>ではでは、早速本題に入っていきます。</p><hr><h1 id=モック使ってますか>モック使ってますか？</h1><hr><p>みなさんモックコードは書いていますか？</p><p>テストコードを書いているなら、ほぼ必ず登場するあのモックです。
DB処理や関数のモックなどいろいろありますよね。</p><p>そんなモックコードですが、作ったり管理するのめんどくさいなぁとか思ってないですか？
モックだからといって雑なコードになっていませんか？</p><p>今回は、外部API通信のモック化にフォーカスし、
モックコードの作成・管理コストを軽減する
VCR ライブラリ を紹介します。</p><hr><h1 id=vcr-ライブラリ-とは>VCR ライブラリ とは？</h1><hr><p>VCR（Video Cassette Recorder）とは、通信を保存し、再生するライブラリです。</p><p>つまり、APIリクエストの初回通信の内容を保存し、
次回以降その保存内容（レスポンス）を使いまわしてくれるというものです。</p><p>言い換えれば、外部APIのモックを自動生成してくれるということですね！</p><h2 id=vcr-ライブラリ-in-golang-world>VCR ライブラリ in Golang World</h2><p>Golang 用の VCR ライブラリは<a href="https://github.com/search?l=Go&q=vcr&type=Repositories">いろいろあります</a>。
スター数が多いのは以下のものです。</p><ul><li><a href=https://github.com/dnaeon/go-vcr>go-vcr</a></li><li><a href=https://github.com/ComboStrikeHQ/vcr-go>vcr-go</a></li><li><a href=https://github.com/seborama/govcr>govcr</a></li><li><a href=https://github.com/googleapis/google-cloud-go/tree/master/rpcreplay>rpcreplay</a></li></ul><p>go-vcr および vcr-go，govcr の開発は盛んではないようです。</p><p>rpcreplay は <a href=https://github.com/googleapis/google-cloud-go>google-cloud-go</a>に包含されるパッケージであり、安心して使えそうです。
ただし、gRPC 用なので、その点は注意が必要です。
<a href=https://godoc.org/cloud.google.com/go/rpcreplay>GoDocはこちら</a>です。</p><p>今回は REST API を使って説明していくので、go-vcr を使用します。</p><p>go-vcr は、vcr-go と govcr よりスター数が多いです。
Ruby 製の <a href=https://github.com/vcr/vcr>vcr</a> というライブラリがもとになっているようです。</p><hr><h1 id=サンプルを見ていく>サンプルを見ていく</h1><hr><p>では、コードを交えて紹介していきたいと思います。
今回は下記のような簡単なサンプルを用意しました。</p><p>（最終的なサンプルコードは<a href=https://github.com/yyh-gl/go-vcr-sample>こちら</a>にあります。）</p><p>Qiitaのユーザ情報取得APIを呼び出し、
レスポンス内容（ID と Location のみ）を表示するだけの簡単なプログラムです。</p><pre class=line-numbers><code class=language-go>// /main.go

package main

import (
	&quot;fmt&quot;

	&quot;github.com/yyh-gl/go-vcr-sample/qiita&quot;
)

func main() {
	user := qiita.FetchUser(&quot;yyh-gl&quot;)
	fmt.Println(&quot;============ RESULT ============&quot;)
	fmt.Printf(&quot;%+v\n&quot;, user)
	fmt.Println(&quot;============ RESULT ============&quot;)
}
</code></pre><pre class=line-numbers><code class=language-go>// /qiita/qiita.go

package qiita

import (
	&quot;encoding/json&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

type User struct {
	ID       string
	Location string
}

func FetchUser(id string) (user *User) {
	req, _ := http.NewRequest(&quot;GET&quot;, &quot;https://qiita.com/api/v2/users/&quot;+id, nil)

	client := new(http.Client)
	resp, _ := client.Do(req)
	defer resp.Body.Close()

	body, _ := ioutil.ReadAll(resp.Body)
	_ = json.Unmarshal(body, &amp;user)
	return user
}
</code></pre><p>実行してみると、、、</p><pre class=line-numbers><code class=language-zsh>$ go run main.go
============ RESULT ============
&amp;{ID:yyh-gl Location:Tokyo, Japan}
============ RESULT ============
</code></pre><p>ちゃんと ID と Location が表示できていますね。</p><hr><h1 id=テストしたい>テストしたい</h1><hr><p>今回のサンプルは簡単なコードですがテストを書くことにします。</p><p>・
・
・</p><pre class=line-numbers><code class=language-go>// /qiita/qiita_test.go

package qiita_test

import (
	&quot;testing&quot;

	&quot;github.com/stretchr/testify/assert&quot;
	&quot;github.com/yyh-gl/go-vcr-sample/qiita&quot;
)

func Test_FetchUser(t *testing.T) {
	tests := []struct {
		testCase     string
		id           string
		wantLocation string
	}{
		{
			testCase:     &quot;Qiitaからyyh-glのユーザ情報を取得できていること&quot;,
			id:           &quot;yyh-gl&quot;,
			wantLocation: &quot;Tokyo, Japan&quot;,
		},
	}

	for _, tt := range tests {
		t.Run(tt.testCase, func(t *testing.T) {
			user := qiita.FetchUser(tt.id)
			assert.Equal(t, tt.wantLocation, user.Location)
		})
	}
}
</code></pre><p>書きました。</p><pre class=line-numbers><code class=language-zsh>$ go test ./...
?   	github.com/yyh-gl/go-vcr-sample	[no test files]
ok  	github.com/yyh-gl/go-vcr-sample/qiita	0.313s
</code></pre><p>ちゃんとテストが通りますね。</p><p>しかし、このままではテストのたびに
Qiita API にリクエストが飛んでしまうので良くないですね。</p><p>ここで、本日の主役 go-vcr を導入していきましょう。</p><hr><h1 id=go-vcr-のセットアップ>go-vcr のセットアップ</h1><hr><p>VCR ライブラリは通信内容を保存します。
つまり、通信を傍受する必要があります。</p><p>go-vcr では、http.Client の Transport を go-vcr で用意されたものに差し替えることで、
通信の傍受を可能にします。</p><p>したがって、まずは独自の http.Client を差し込めるように、
サンプルのコードを修正していきます。</p><h2 id=qiita-api-用の-http-クライアントを作る>Qiita API 用の HTTP クライアントを作る</h2><p>まず、<code>qiita.go</code> に HTTP クライアント生成関数を作ります。</p><pre class=line-numbers><code class=language-go>// /qiita/qiita.go

package qiita

import (
	&quot;encoding/json&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
)

// ここ
type Client struct {
	*http.Client
}

// ここ
func NewClient(c *http.Client) Client {
	return Client{c}
}

type User struct {
	ID       string
	Location string
}

// ここ
func (c Client) FetchUser(id string) (user *User) {
	req, _ := http.NewRequest(&quot;GET&quot;, &quot;https://qiita.com/api/v2/users/&quot;+id, nil)

	resp, _ := c.Do(req) // ここ
	defer resp.Body.Close()

	body, _ := ioutil.ReadAll(resp.Body)
	_ = json.Unmarshal(body, &amp;user)
	return user
}
</code></pre><p><code>main.go</code> と <code>qiita_test.go</code> も直します。</p><pre class=line-numbers><code class=language-go>// /main.go

package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;

	&quot;github.com/yyh-gl/go-vcr-sample/qiita&quot;
)

func main() {
	// ここ
	qiitaClient := qiita.NewClient(http.DefaultClient)
	user := qiitaClient.FetchUser(&quot;yyh-gl&quot;)
	fmt.Println(&quot;============ RESULT ============&quot;)
	fmt.Printf(&quot;%+v\n&quot;, user)
	fmt.Println(&quot;============ RESULT ============&quot;)
}
</code></pre><pre class=line-numbers><code class=language-go>// /qiita/qiita_test.go

package qiita_test

import (
	&quot;net/http&quot;
	&quot;testing&quot;

	&quot;github.com/stretchr/testify/assert&quot;
	&quot;github.com/yyh-gl/go-vcr-sample/qiita&quot;
)

func Test_FetchUser(t *testing.T) {
	tests := []struct {
		testCase     string
		id           string
		wantLocation string
	}{
		{
			testCase:     &quot;Qiitaからyyh-glのユーザ情報を取得できていること&quot;,
			id:           &quot;yyh-gl&quot;,
			wantLocation: &quot;Tokyo, Japan&quot;,
		},
	}

    // ここ
	qiitaClient := qiita.NewClient(http.DefaultClient)

	for _, tt := range tests {
		t.Run(tt.testCase, func(t *testing.T) {
			user := qiitaClient.FetchUser(tt.id)
			assert.Equal(t, tt.wantLocation, user.Location)
		})
	}
}
</code></pre><p>この状態でテストを実行すると、、、</p><pre class=line-numbers><code class=language-zsh>$ go test ./...
?   	github.com/yyh-gl/go-vcr-sample	[no test files]
ok  	github.com/yyh-gl/go-vcr-sample/qiita	0.293s
</code></pre><p>ちゃんと通りますね。</p><p>さて、これで <code>NewClient()</code> に渡す引数（http.Client）しだいで、
使用する HTTP クライアント変更できるようになりました。</p><h2 id=go-vcr-導入>go-vcr 導入</h2><p>ここから go-vcr を導入して、外部APIとの通信を保存・再生していくのですが、
めちゃくちゃ簡単です。</p><p>今回はテストにおいて、外部APIとの通信部分をモック化したいので、
<code>qiita_test.go</code> を直していきます。</p><pre class=line-numbers><code class=language-go>// /qiita_test.go

package qiita_test

import (
	&quot;net/http&quot;
	&quot;testing&quot;

	&quot;github.com/dnaeon/go-vcr/recorder&quot;
	&quot;github.com/stretchr/testify/assert&quot;
	&quot;github.com/yyh-gl/go-vcr-sample/qiita&quot;
)

func Test_FetchUser(t *testing.T) {
	tests := []struct {
		testCase     string
		id           string
		wantLocation string
	}{
		{
			testCase:     &quot;Qiitaからyyh-glのユーザ情報を取得できていること&quot;,
			id:           &quot;yyh-gl&quot;,
			wantLocation: &quot;Tokyo, Japan&quot;,
		},
	}

    // ここ
	// go-vcr のレコーダを生成
	// 通信内容は ../fixtures/qiita に保存される
	r, _ := recorder.New(&quot;../fixtures/qiita&quot;)
	defer r.Stop()

	customHTTPClient := &amp;http.Client{
		Transport: r, // ここ 重要！
	}
	qiitaClient := qiita.NewClient(customHTTPClient)

	for _, tt := range tests {
		t.Run(tt.testCase, func(t *testing.T) {
			user := qiitaClient.FetchUser(tt.id)
			assert.Equal(t, tt.wantLocation, user.Location)
		})
	}
}
</code></pre><p>以上で終了です。</p><p>この状態で <code>$ go test ./...</code> してみると、</p><pre class=line-numbers><code class=language-zsh>$ go test ./...
?   	github.com/yyh-gl/go-vcr-sample	[no test files]
ok  	github.com/yyh-gl/go-vcr-sample/qiita	0.472s
</code></pre><p>普通にテストが通りますね。</p><p>では、この状態で、ネットワーク（WiFi）を切って、再度テストしてみます。</p><pre class=line-numbers><code class=language-zsh>$ go test ./...
?   	github.com/yyh-gl/go-vcr-sample	[no test files]
ok  	github.com/yyh-gl/go-vcr-sample/qiita	0.014s
</code></pre><p>成功しました。
&ldquo;保存された通信内容"を見ているので、ネットワークに繋がっていなくても、テストが通ります。
（&ldquo;保存された通信内容"がどこにあるかは後で説明します）
つまり、モック化できてしまっているのです！</p><p>しかも、実行時間が短くなっていますね！これはでかい。</p><p>では、&ldquo;保存された通信内容"を消して、再度テストしてみましょう。</p><pre class=line-numbers><code class=language-zsh>$ go test ./...
?   	github.com/yyh-gl/go-vcr-sample	[no test files]
panic: runtime error: invalid memory address or nil pointer dereference [recovered]
	panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x40 pc=0x12aef8d]

goroutine 21 [running]:
testing.tRunner.func1(0xc0000fe200)
	/Users/yyh-gl/.anyenv/envs/goenv/versions/1.13.4/src/testing/testing.go:874 +0x3a3
panic(0x1343900, 0x1642f80)
	/Users/yyh-gl/.anyenv/envs/goenv/versions/1.13.4/src/runtime/panic.go:679 +0x1b2
github.com/yyh-gl/go-vcr-sample/qiita.Client.FetchUser(0xc00008b2c0, 0x13a96ac, 0x6, 0x104fe28)
	/Users/yyh-gl/workspaces/Go/src/github.com/yyh-gl/go-vcr-sample/qiita/qiita.go:26 +0x10d
github.com/yyh-gl/go-vcr-sample/qiita_test.Test_FetchUser.func1(0xc0000fe200)
	/Users/yyh-gl/workspaces/Go/src/github.com/yyh-gl/go-vcr-sample/qiita/qiita_test.go:37 +0x49
testing.tRunner(0xc0000fe200, 0xc0000a0540)
	/Users/yyh-gl/.anyenv/envs/goenv/versions/1.13.4/src/testing/testing.go:909 +0xc9
created by testing.(*T).Run
	/Users/yyh-gl/.anyenv/envs/goenv/versions/1.13.4/src/testing/testing.go:960 +0x350
FAIL	github.com/yyh-gl/go-vcr-sample/qiita	0.020s
FAIL
</code></pre><p>エラーになりましたね。
ちゃんとエラーハンドリングしていないので、nil参照のエラーになっていますが、
これはネットワークに繋がっていない（＋"保存された通信内容"がない）ために、
外部APIへのリクエストが失敗し、発生したエラーです。</p><hr><h1 id=保存された通信内容>&ldquo;保存された通信内容&rdquo;</h1><hr><p>では、さきほど go test を初めて実行したときに何が起こっていたのかを説明します。</p><p>プロジェクト内を見てみると、</p><pre class=line-numbers><code class=language-zsh>$ tree go-vcr-sample
go-vcr-sample
├── fixtures
│   └── qiita.yaml
├── go.mod
├── go.sum
├── main.go
└── qiita
    ├── qiita.go
    └── qiita_test.go
</code></pre><p><code>fixtures</code> ディレクトリができています。</p><p>中身を見てみると、</p><pre class=line-numbers><code class=language-zsh>$ ls fixtures
qiita.yaml
</code></pre><p><code>qiita.yaml</code> ができています。</p><pre class=line-numbers><code class=language-yaml># /fixtures/qiita.yaml

---
version: 1
interactions:
- request:
    body: &quot;&quot;
    form: {}
    headers: {}
    url: https://qiita.com/api/v2/users/yyh-gl
    method: GET
  response:
    body: &quot;{\&quot;description\&quot;:\&quot;東京でエンジニアしてます／CLI名刺 $ npx yyh-gl／メインは個人ブログです\U0001F4DD\&quot;,\&quot;facebook_id\&quot;:\&quot;\&quot;,\&quot;followees_count\&quot;:19,\&quot;followers_count\&quot;:18,\&quot;github_login_name\&quot;:\&quot;yyh-gl\&quot;,\&quot;id\&quot;:\&quot;yyh-gl\&quot;,\&quot;items_count\&quot;:11,\&quot;linkedin_id\&quot;:\&quot;\&quot;,\&quot;location\&quot;:\&quot;Tokyo,
      Japan\&quot;,\&quot;name\&quot;:\&quot;\&quot;,\&quot;organization\&quot;:\&quot;\&quot;,\&quot;permanent_id\&quot;:119088,\&quot;profile_image_url\&quot;:\&quot;https://qiita-image-store.s3.amazonaws.com/0/119088/profile-images/1535528464\&quot;,\&quot;team_only\&quot;:false,\&quot;twitter_screen_name\&quot;:null,\&quot;website_url\&quot;:\&quot;https://yyh-gl.github.io/tech-blog/\&quot;}&quot;
    headers:
      Cache-Control:
      - max-age=0, private, must-revalidate
      Content-Type:
      - application/json; charset=utf-8
      Date:
      - Sat, 07 Dec 2019 07:27:05 GMT
      Etag:
      - W/&quot;a6adaa36bf27d2045a25659539dcdae5&quot;
      Rate-Limit:
      - &quot;60&quot;
      Rate-Remaining:
      - &quot;56&quot;
      Rate-Reset:
      - &quot;1575706459&quot;
      Referrer-Policy:
      - strict-origin-when-cross-origin
      Server:
      - nginx
      Strict-Transport-Security:
      - max-age=2592000
      Vary:
      - Origin
      X-Content-Type-Options:
      - nosniff
      X-Download-Options:
      - noopen
      X-Frame-Options:
      - SAMEORIGIN
      X-Permitted-Cross-Domain-Policies:
      - none
      X-Request-Id:
      - f0ca74f0-4aae-4d0f-b6f9-ec08b0407b56
      X-Runtime:
      - &quot;0.082646&quot;
      X-Xss-Protection:
      - 1; mode=block
    status: 200 OK
    code: 200
    duration: &quot;&quot;
</code></pre><p>リクエストおよびレスポンスの内容が全て保存されています。</p><p>このように、go-vcr では、通信内容を傍受して、yaml 形式で保存します。
（内容自体も、Web エンジニアならよく見かける単語ばかりなので読みやすいですね）</p><p>そして、この yaml ファイルがあるときは、外部APIに対してリクエストを飛ばさずに、
yaml ファイルの内容からレスポンスを返します。</p><hr><h1 id=リクエスト済みかどうかの判断方法>リクエスト済みかどうかの判断方法</h1><hr><p>ここで、go-vcr がどのようにして、
リクエストを送ったことがあるかどうかを判定しているのか説明していきます。</p><p>答えは<a href=https://github.com/dnaeon/go-vcr/blob/9384691f0462689770c3e930cd8aff05c7075a5b/cassette/cassette.go#L103-L107>こちら</a>のコードにあります。</p><pre class=line-numbers><code class=language-go>// DefaultMatcher is used when a custom matcher is not defined
// and compares only the method and URL.
func DefaultMatcher(r *http.Request, i Request) bool {
	return r.Method == i.Method &amp;&amp; r.URL.String() == i.URL
}
</code></pre><blockquote><p>compares only the method and URL.</p></blockquote><p>デフォルトだと、HTTP メソッドとリクエストURL しか見てないんですね。</p><p>しかし、この判定処理において、
HTTP メソッドとリクエストURL以外も見るようにしたかったり、
逆にこのURLへのリクエストだけは保存したくないといったニーズもあると思います。
そこで 登場するのが Custom Request Matching です。</p><h2 id=custom-request-matching>Custom Request Matching</h2><p><a href=https://github.com/dnaeon/go-vcr#custom-request-matching>README.md</a> にもあるとおり、
Matcher を作ってあげるだけで、簡単にオリジナルの判定処理を実装可能です。</p><p>さきほどの README.md にあるサンプルを拝借して、
僕のコード書き換えてみると以下のとおりになります。</p><pre class=line-numbers><code class=language-go>// /qiita/qiita_test.go

package qiita_test

import (
	&quot;bytes&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;testing&quot;

	&quot;github.com/dnaeon/go-vcr/cassette&quot;

	&quot;github.com/dnaeon/go-vcr/recorder&quot;
	&quot;github.com/stretchr/testify/assert&quot;
	&quot;github.com/yyh-gl/go-vcr-sample/qiita&quot;
)

func Test_FetchUser(t *testing.T) {
	tests := []struct {
		testCase     string
		id           string
		wantLocation string
	}{
		{
			testCase:     &quot;Qiitaからyyh-glのユーザ情報を取得できていること&quot;,
			id:           &quot;yyh-gl&quot;,
			wantLocation: &quot;Tokyo, Japan&quot;,
		},
	}

	// go-vcr のレコーダを生成
	// 通信内容は ../fixtures/qiita に保存される
	r, _ := recorder.New(&quot;../fixtures/qiita&quot;)
	defer r.Stop()

    // ここ
	r.SetMatcher(func(r *http.Request, i cassette.Request) bool {
		if r.Body == nil {
			return cassette.DefaultMatcher(r, i)
		}
		var b bytes.Buffer
		if _, err := b.ReadFrom(r.Body); err != nil {
			return false
		}
		r.Body = ioutil.NopCloser(&amp;b)
		return cassette.DefaultMatcher(r, i) &amp;&amp; (b.String() == &quot;&quot; || b.String() == i.Body)
	})

	customHTTPClient := &amp;http.Client{
		Transport: r,
	}
	qiitaClient := qiita.NewClient(customHTTPClient)

	for _, tt := range tests {
		t.Run(tt.testCase, func(t *testing.T) {
			user := qiitaClient.FetchUser(tt.id)
			assert.Equal(t, tt.wantLocation, user.Location)
		})
	}
}
</code></pre><p><code>SetMatcher()</code> 内の処理によって、判定ロジックを変更します。
この例だと、HTTP メソッドとリクエストURL に加えて、リクエストBody の内容も見るようになっています。</p><p>このように、<code>SetMatcher()</code> を定義してやるだけです。
後はいつもどおり、http.Client の Transport に渡してやるだけなので簡単ですね👍</p><hr><h1 id=保存内容を修正する必要が出たときはどうする>保存内容を修正する必要が出たときはどうする？</h1><hr><p>yaml ファイルを消すだけです。</p><p>例えば、外部APIの仕様が変わり、モックを更新する必要が出てきた場合は、
yaml ファイルを消してやるだけで、次のAPIリクエストの内容を保存 => つまり、モックを更新できます。</p><p>もちろん yaml ファイルを直接変更することもできます。</p><p>モックの管理が楽になりますね👍</p><hr><h1 id=まとめ>まとめ</h1><hr><p>go-vcr を利用することで、外部API通信のモック化および管理が簡単にできるようになりました。
しかも、モックの内容は、実際にリクエストして得た内容なので、
仕様が漏れることもないでしょう。</p><p>また、今回は説明しませんでしたが、
go-vcr には <a href=https://github.com/dnaeon/go-vcr#protecting-sensitive-data>Protecting Sensitive Data</a> という機能もあり、
指定したデータを保存しないようにするといったこともできます。</p><p>カスタマイズ性が高く、とてもおすすめのライブラリです。</p><p>もしモックの作成・管理で悩んでいる方がおられたら、
ぜひ一度検討してみてください！</p><p>Go3 Advent Calendar 2019、明日は <a href=https://qiita.com/EbiEbiEvidence>EbiEbiEvidence</a> さんです🛫</p></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/tech-blog/categories/go/>Go</a></li><li><a class=article-terms-link href=/tech-blog/categories/%e3%83%86%e3%82%b9%e3%83%88/>テスト</a></li><li><a class=article-terms-link href=/tech-blog/categories/advent-calendar/>Advent Calendar</a></li></ul><div><good-counter url=/tech-blog/blog/golang-vcr/></good-counter></div></div></footer></article><div class=pagination><a href=/tech-blog/blog/golangci-lint-custom-settings/ class="button left"><span>GolangCI-Lintの設定ファイルを理解する</span></a>
<a href=/tech-blog/blog/react_typescript_sample/ class="button right"><span>【React+TypeScript】TypeScript入門</span></a></div></main><section id=site-sidebar><section id=recent-posts><header><h1>最近の投稿</h1></header><article class=mini-post><a href=/tech-blog/blog/go-switch-fallthrough/ class=image style="--bg-image: url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/10/go-switch-fallthrough/featured.png')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/10/go-switch-fallthrough/featured.png alt=featured></a><header><h2><a href=/tech-blog/blog/go-switch-fallthrough/>【Go】Switch文のfallthroughに関するまとめ</a></h2><time class=published datetime="2020-10-03 00:00:00 +0000 UTC">2020-10-03</time></header></article><article class=mini-post><a href=/tech-blog/blog/podcast-matome-texta-200827/ class=image style="--bg-image: url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/10/podcast-matome-texta-200827/featured.png')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/10/podcast-matome-texta-200827/featured.png alt=featured></a><header><h2><a href=/tech-blog/blog/podcast-matome-texta-200827/>texta.fm #1 まとめ</a></h2><time class=published datetime="2020-10-01 00:00:00 +0000 UTC">2020-10-01</time></header></article><article class=mini-post><a href=/tech-blog/blog/go-always-passing-by-value/ class=image style="--bg-image: url('https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/06/go-always-passing-by-value/featured.png')"><img src=https://yyh-gl.github.io/tech-blog/img/tech-blog/2020/06/go-always-passing-by-value/featured.png alt=featured></a><header><h2><a href=/tech-blog/blog/go-always-passing-by-value/>Goの参照渡しについて調べてみた</a></h2><time class=published datetime="2020-06-14 00:00:00 +0000 UTC">2020-06-14</time></header></article><footer><a href=/tech-blog/blog/ class=button>続きを見る</a></footer></section><section id=categories><header><h1><a href=/tech-blog/categories>Categories</a></h1></header><ul><li><a href=/tech-blog/categories/go/>go<span class=count>17</span></a><li><a href=/tech-blog/categories/%E5%8B%89%E5%BC%B7%E4%BC%9A/>勉強会<span class=count>6</span></a><li><a href=/tech-blog/categories/ddd/>ddd<span class=count>5</span></a><li><a href=/tech-blog/categories/advent-calendar/>advent-calendar<span class=count>3</span></a><li><a href=/tech-blog/categories/web-api/>web-api<span class=count>3</span></a><li><a href=/tech-blog/categories/%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3/>アーキテクチャ<span class=count>3</span></a><li><a href=/tech-blog/categories/%E8%AA%AD%E6%9B%B8%E3%81%BE%E3%81%A8%E3%82%81/>読書まとめ<span class=count>3</span></a><li><a href=/tech-blog/categories/html/css/>html/css<span class=count>2</span></a><li><a href=/tech-blog/categories/react/>react<span class=count>2</span></a><li><a href=/tech-blog/categories/web%E5%85%A8%E8%88%AC/>web全般<span class=count>2</span></a><li><a href=/tech-blog/categories/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3/>セキュリティ<span class=count>2</span></a><li><a href=/tech-blog/categories/%E3%83%86%E3%82%B9%E3%83%88/>テスト<span class=count>2</span></a><li><a href=/tech-blog/categories/android/>android<span class=count>1</span></a><li><a href=/tech-blog/categories/aws/>aws<span class=count>1</span></a><li><a href=/tech-blog/categories/ci/cd/>ci/cd<span class=count>1</span></a><li><a href=/tech-blog/categories/ecs/>ecs<span class=count>1</span></a><li><a href=/tech-blog/categories/firebase/>firebase<span class=count>1</span></a><li><a href=/tech-blog/categories/github/>github<span class=count>1</span></a><li><a href=/tech-blog/categories/kotlin/>kotlin<span class=count>1</span></a><li><a href=/tech-blog/categories/lint/>lint<span class=count>1</span></a><li><a href=/tech-blog/categories/podcast/>podcast<span class=count>1</span></a><li><a href=/tech-blog/categories/rds/>rds<span class=count>1</span></a><li><a href=/tech-blog/categories/terraform/>terraform<span class=count>1</span></a><li><a href=/tech-blog/categories/typescript/>typescript<span class=count>1</span></a><li><a href=/tech-blog/categories/vue.js/>vue.js<span class=count>1</span></a><li><a href=/tech-blog/categories/%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%A0/>スクラム<span class=count>1</span></a><li><a href=/tech-blog/categories/%E3%83%81%E3%83%BC%E3%83%A0%E3%83%9E%E3%83%8D%E3%82%B8%E3%83%A1%E3%83%B3%E3%83%88/>チームマネジメント<span class=count>1</span></a><li><a href=/tech-blog/categories/%E3%83%9D%E3%82%A8%E3%83%A0/>ポエム<span class=count>1</span></a><li><a href=/tech-blog/categories/%E5%85%A5%E9%96%80/>入門<span class=count>1</span></a><li><a href=/tech-blog/categories/%E7%B0%A1%E5%8D%98%E3%81%BE%E3%81%A8%E3%82%81/>簡単まとめ<span class=count>1</span></a><li><a href=/tech-blog/categories/%E8%87%AA%E5%B7%B1%E7%B4%B9%E4%BB%8B/>自己紹介<span class=count>1</span></a></li></ul></section><section id=mini-bio><header><h1>About</h1></header><p>東京で働くソフトウェアエンジニアです。バックエンドがメインですが、フロントやインフラもさわっています。</p><footer><a href=/tech-blog/about class=button>もっと詳しく知る</a></footer></section></section><footer id=site-footer><ul class=socnet-icons><li><a href=//github.com/yyh-gl target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//twitter.com/yyh_gl target=_blank rel=noopener title=Twitter class="fab fa-twitter"></a></li></ul><p class=copyright>© 2020 yyh-gl's Tech Blog<br>Theme: <a href=https://github.com/pacollins/hugo-future-imperfect-slim target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>A <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP port</a> | Powered by <a href=https://gohugo.io/ title=0.78.1 target=_blank rel=noopener>Hugo</a></p></footer><a id=back-to-top href=# class="fas fa-arrow-up fa-2x"></a><script src=/tech-blog/js/bundle.min.9b91c99a740686e4f6235670162f00daf37d4e9ea3ee7852cb78ce7123afa64e.js integrity="sha256-m5HJmnQGhuT2I1ZwFi8A2vN9Tp6j7nhSy3jOcSOvpk4="></script><script src=/tech-blog/js/add-on.js></script><script src=/tech-blog/js/prism.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-140914324-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></div></body></html>